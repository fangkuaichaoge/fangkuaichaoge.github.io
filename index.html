<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft 4Dçš®è‚¤åŒ…åˆå¹¶å·¥å…·</title><!-- å…³æ³¨bç«™fangkuaichaogeå–µï¼Œå…³æ³¨fangkuaichaogeè°¢è°¢å–µ --><!-- å¼•å…¥å­—ä½“å›¾æ ‡ -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- å¼•å…¥ç°ä»£å­—ä½“ -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&amp;display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', 'Microsoft YaHei', 'Arial', sans-serif;
        }

        body {
            background: #f0f2f5;
            padding: 20px 15px;
            max-width: 1000px;
            margin: 0 auto;
            min-height: 100vh;
        }

        .container {
            background: white;
            padding: 30px 20px;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease;
        }

        .container:hover {
            transform: translateY(-2px);
        }

        h1 {
            color: #1a73e8;
            text-align: center;
            margin-bottom: 30px;
            font-size: 26px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        h1 i {
            font-size: 32px;
        }

        .upload-area {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .upload-box {
            flex: 1;
            min-width: 280px;
            border: 2px dashed #1a73e8;
            border-radius: 12px;
            padding: 35px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .upload-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(26, 115, 232, 0.05), transparent);
            transition: 0.5s;
        }

        .upload-box:hover::before {
            left: 100%;
        }

        .upload-box:hover {
            border-color: #0d47a1;
            background: #f8fafc;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(26, 115, 232, 0.08);
        }

        .upload-box.active {
            border-color: #34a853;
            background: #f6ffed;
        }

        .upload-icon {
            font-size: 56px;
            color: #1a73e8;
            margin-bottom: 18px;
            transition: transform 0.3s ease;
        }

        .upload-box:hover .upload-icon {
            transform: scale(1.1);
        }

        .upload-text {
            color: #5f6368;
            margin-bottom: 12px;
            font-size: 15px;
            line-height: 1.5;
        }

        .file-list {
            text-align: left;
            margin-top: 18px;
            max-height: 120px;
            overflow-y: auto;
            font-size: 14px;
            color: #3c4043;
            padding-right: 8px;
        }

        .file-list::-webkit-scrollbar {
            width: 6px;
        }

        .file-list::-webkit-scrollbar-thumb {
            background-color: #dadce0;
            border-radius: 3px;
        }

        .file-list div {
            padding: 4px 0;
            border-bottom: 1px solid #f1f3f4;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-list div:last-child {
            border-bottom: none;
        }

        .file-list i {
            font-size: 12px;
            color: #1a73e8;
        }

        /* æ–°å¢ï¼šé…ç½®é¢„è®¾åŒºåŸŸæ ·å¼ */
        .presets {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 10px;
            border: 1px solid #e8eaed;
        }

        .presets h3 {
            color: #3c4043;
            margin-bottom: 12px;
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .presets h3 i {
            color: #1a73e8;
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .preset-btn {
            padding: 8px 16px;
            background: #e8eaed;
            color: #3c4043;
            border: none;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            position: relative;
            overflow: hidden;
            font-weight: 500;
        }

        .preset-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(26, 115, 232, 0.1), transparent);
            transition: 0.5s;
        }

        .preset-btn:hover::before {
            left: 100%;
        }

        .preset-btn:hover {
            background: #dadce0;
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .preset-btn.active {
            background: #1a73e8;
            color: white;
            box-shadow: 0 2px 8px rgba(26, 115, 232, 0.3);
        }

        .preset-btn.active:hover {
            background: #0d47a1;
        }

        /* é¢„è®¾è¯´æ˜æ–‡å­— */
        .preset-description {
            font-size: 12px;
            color: #5f6368;
            margin-top: 10px;
            line-height: 1.4;
            padding-top: 10px;
            border-top: 1px dashed #dadce0;
        }

        .options {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 15px;
        }

        .option-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #3c4043;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #1a73e8;
        }

        input:checked+.slider:before {
            transform: translateX(20px);
        }

        .btn-merge {
            display: block;
            width: 100%;
            padding: 16px;
            background: #ea4335;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .btn-merge:hover {
            background: #d93025;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(234, 67, 53, 0.3);
        }

        .btn-merge:disabled {
            background: #f1f3f4;
            color: #9aa0a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .progress {
            margin-bottom: 25px;
            display: none;
            padding: 15px;
            background: #f8fafc;
            border-radius: 10px;
        }

        .progress-bar {
            height: 10px;
            background: #e8eaed;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .progress-fill {
            height: 100%;
            background: #34a853;
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 5px;
        }

        .progress-text {
            color: #5f6368;
            font-size: 15px;
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .progress-text i {
            animation: spin 1.5s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .result {
            display: none;
            text-align: center;
            margin-top: 25px;
            padding: 20px;
            background: #f6ffed;
            border-radius: 12px;
            border: 1px solid #d9e9be;
        }

        .result h3 {
            color: #137333;
            margin-bottom: 18px;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .btn-download {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 12px 30px;
            background: #1a73e8;
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(26, 115, 232, 0.2);
        }

        .btn-download:hover {
            background: #0d47a1;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(26, 115, 232, 0.3);
        }

        .log {
            background: #f8fafc;
            border-radius: 12px;
            padding: 18px;
            margin-top: 25px;
            max-height: 220px;
            overflow-y: auto;
            font-size: 14px;
            color: #3c4043;
            border: 1px solid #e8eaed;
        }

        .log>div:first-child {
            font-weight: 600;
            color: #1a73e8;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e8eaed;
        }

        .log div {
            padding: 4px 0;
            line-height: 1.5;
        }

        .log::-webkit-scrollbar {
            width: 8px;
        }

        .log::-webkit-scrollbar-thumb {
            background-color: #dadce0;
            border-radius: 4px;
        }

        .log::-webkit-scrollbar-track {
            background: #f1f3f4;
            border-radius: 4px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px 15px;
            }

            h1 {
                font-size: 22px;
            }

            .upload-box {
                min-width: 100%;
                padding: 25px 15px;
            }

            .upload-icon {
                font-size: 48px;
            }

            .preset-buttons {
                flex-direction: column;
            }

            .preset-btn {
                width: 100%;
                text-align: center;
            }

            .btn-merge {
                padding: 14px;
                font-size: 16px;
            }

            .log {
                max-height: 180px;
                font-size: 13px;
            }
        }
    </style><!-- å¼•å…¥å¤„ç†ZIPå’Œæ–‡ä»¶ä¸‹è½½çš„åº“ -->
    <script src="./js/jszip.min.js"></script>
    <script src="./js/FileSaver.min.js"></script>
</head>

<body>
    <div class="container">
        <h1><i class="fas fa-cube"></i>Minecraftçš®è‚¤åŒ…åˆå¹¶å·¥å…·</h1>
        <div class="upload-area">
            <div class="upload-box" id="upload1">
                <div class="upload-icon"><i class="fas fa-file-archive"></i></div>
                <div class="upload-text">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ ç¬¬ä¸€ä¸ªçš®è‚¤åŒ…ï¼ˆZIP/æ–‡ä»¶å¤¹ï¼‰</div>
                <div class="file-list" id="fileList1"></div><input type="file" id="fileInput1" style="display: none;"
                    accept=".zip,.json,.png,.jpg,.jpeg" multiple>
            </div>
            <div class="upload-box" id="upload2">
                <div class="upload-icon"><i class="fas fa-file-archive"></i></div>
                <div class="upload-text">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ ç¬¬äºŒä¸ªçš®è‚¤åŒ…ï¼ˆZIP/æ–‡ä»¶å¤¹ï¼‰</div>
                <div class="file-list" id="fileList2"></div><input type="file" id="fileInput2" style="display: none;"
                    accept=".zip,.json,.png,.jpg,.jpeg" multiple>
            </div>
        </div><!-- æ–°å¢ï¼šé…ç½®é¢„è®¾åŒºåŸŸ -->
        <div class="presets">
            <h3><i class="fas fa-magic"></i>é…ç½®é¢„è®¾</h3>
            <div class="preset-buttons"><button class="preset-btn"
                    data-preset="1">é¢„è®¾1ï¼šçš®è‚¤/æ¨¡å‹/æ³¨é‡Šå…¼å®¹ï¼ˆæŠ¥é”™å¯ç”¨è¿™ä¸ªï¼‰</button><button class="preset-btn"
                    data-preset="2">é¢„è®¾2ï¼šå¯åŠ¨å™¨é€‚é…</button><button class="preset-btn"
                    data-preset="3">é¢„è®¾3ï¼šçš®è‚¤åç®€åŒ–åˆå¹¶</button><button class="preset-btn" data-preset="4">é¢„è®¾4ï¼šçš®è‚¤åˆå¹¶å…¨èƒ½ç‰ˆ</button>
            </div>
            <div class="preset-description"><i class="fas fa-info-circle"></i>ç‚¹å‡»é¢„è®¾å¯å¿«é€Ÿé…ç½®å¸¸ç”¨é€‰é¡¹ç»„åˆï¼Œå¯ä¸æ‰‹åŠ¨è®¾ç½®å åŠ ä½¿ç”¨</div>
        </div><!-- å‘½åç®€åŒ–é€‰é¡¹ -->
        <div class="options"><!-- æ–°å¢ï¼šå¯ç”¨é‡åæ¨¡å‹å…¼å®¹ï¼ˆä¼˜å…ˆçº§é«˜äºå‘½åç®€åŒ–ï¼‰ -->
            <div class="option-item"><label class="toggle-switch"><input type="checkbox"
                        id="compatibleRenameModel"><span class="slider"></span></label><span>å¯ç”¨é‡åæ¨¡å‹å…¼å®¹</span></div>
            <div class="option-item"><label class="toggle-switch"><input type="checkbox" id="simplifyNaming"><span
                        class="slider"></span></label><span>å¯ç”¨å‘½åç®€åŒ–</span></div>
            <div class="option-item"><label class="toggle-switch"><input type="checkbox" id="replaceUuid"><span
                        class="slider"></span></label><span>å¯ç”¨UUIDæ›¿æ¢</span></div>
            <div class="option-item"><label class="toggle-switch"><input type="checkbox" id="addHideArmor"><span
                        class="slider"></span></label><span>å¯ç”¨éšè—ç›”ç”²</span></div><!-- æ ¸å¿ƒä¿®æ”¹ï¼šç§»é™¤checkedå±æ€§ï¼Œé»˜è®¤å…³é—­æ³¨é‡Šä¿®å¤ -->
            <div class="option-item"><label class="toggle-switch"><input type="checkbox" id="fixComments"><span
                        class="slider"></span></label><span>å¯ç”¨æ³¨é‡Šä¿®å¤</span></div><!-- æ–°å¢ï¼šå¯ç”¨è¾“å‡ºä¸ºmcpacké€‰é¡¹ -->
            <div class="option-item"><label class="toggle-switch"><input type="checkbox" id="outputMcpack"><span
                        class="slider"></span></label><span>å¯ç”¨è¾“å‡ºä¸ºmcpack</span></div>
        </div><button class="btn-merge" id="mergeBtn" disabled><i class="fas fa-code-branch"></i>å¼€å§‹åˆå¹¶çš®è‚¤åŒ…</button>
        <div class="progress">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText"><i class="fas fa-spinner"></i>å‡†å¤‡åˆå¹¶...</div>
        </div>
        <div class="result" id="result">
            <h3><i class="fas fa-check-circle"></i>åˆå¹¶æˆåŠŸï¼</h3><a href="#" class="btn-download" id="downloadBtn"><i
                    class="fas fa-download"></i>ä¸‹è½½åˆå¹¶åçš„çš®è‚¤åŒ…</a>
        </div>
        <div class="log" id="log">
            <div><i class="fas fa-history"></i>æ—¥å¿—è¾“å‡ºï¼š</div>
        </div>
    </div>
    <script>
        // å…¨å±€å˜é‡
        let skinPack1 = { files: {}, isZip: false, name: '', textureMap: new Map(), geoRenameMap: new Map() };
        let skinPack2 = { files: {}, isZip: false, name: '', textureMap: new Map(), geoRenameMap: new Map() };
        let mergeInProgress = false;
        // æ–°å¢ï¼šå­˜å‚¨æ¨¡å‹-è´´å›¾-çš®è‚¤å…³è”å…³ç³»ï¼ˆé‡åå…¼å®¹ç”¨ï¼‰
        let modelTextureRelations = {
            pack1: {
                modelToTextures: new Map(), // æ¨¡å‹å â†’ å…³è”è´´å›¾åˆ—è¡¨
                textureToModels: new Map(), // è´´å›¾å â†’ å…³è”æ¨¡å‹åˆ—è¡¨
                skinToModel: new Map(),     // çš®è‚¤å â†’ å…³è”æ¨¡å‹å
                skinToTexture: new Map(),    // çš®è‚¤å â†’ å…³è”è´´å›¾åï¼ˆç²¾å‡†åŒ¹é…çš®è‚¤å’Œè´´å›¾ï¼‰
                skinTextureSuffix: new Map() // æ–°å¢ï¼šçš®è‚¤å â†’ è´´å›¾åç¼€ï¼ˆç”¨äºç”Ÿæˆå”¯ä¸€localization_nameï¼‰
            },
            pack2: {
                modelToTextures: new Map(),
                textureToModels: new Map(),
                skinToModel: new Map(),
                skinToTexture: new Map(),
                skinTextureSuffix: new Map()
            }
        };

        // æ–°å¢ï¼šé¢„è®¾é…ç½®å®šä¹‰ï¼ˆç‹¬ç«‹äºè®¾ç½®ï¼Œå¯å åŠ ï¼‰
        const presetConfigs = {
            1: { // é¢„è®¾1ï¼šå¯ç”¨åŒæ¨¡å‹/å›½å¤–åˆ›ä½œè€… çš®è‚¤å…¼å®¹
                name: "åŒæ¨¡å‹å…¼å®¹",
                settings: {
                    compatibleRenameModel: true,
                    fixComments: true
                }
            },
            2: { // é¢„è®¾2ï¼šå¯ç”¨ç¬¬ä¸‰æ–¹å¯åŠ¨å™¨é€‚é…
                name: "å¯åŠ¨å™¨é€‚é…",
                settings: {
                    replaceUuid: true,
                    outputMcpack: true
                }
            },
            3: { // é¢„è®¾3ï¼šåˆå¹¶çš®è‚¤åŒ…ç®€åŒ–ç‰ˆ
                name: "ç®€åŒ–åˆå¹¶",
                settings: {
                    simplifyNaming: true,
                    addHideArmor: true
                }
            },
            4: { // é¢„è®¾4ï¼šå°ç™½æ“ä½œå…¨èƒ½ç‰ˆ
                name: "å…¨èƒ½ç‰ˆ",
                settings: {
                    compatibleRenameModel: true,
                    simplifyNaming: true,
                    replaceUuid: true,
                    addHideArmor: true,
                    fixComments: true
                }
            }
        };

        // DOMå…ƒç´ 
        const upload1 = document.getElementById('upload1');
        const upload2 = document.getElementById('upload2');
        const fileInput1 = document.getElementById('fileInput1');
        const fileInput2 = document.getElementById('fileInput2');
        const fileList1 = document.getElementById('fileList1');
        const fileList2 = document.getElementById('fileList2');
        const mergeBtn = document.getElementById('mergeBtn');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const progress = document.querySelector('.progress');
        const result = document.getElementById('result');
        const downloadBtn = document.getElementById('downloadBtn');
        const log = document.getElementById('log');
        const simplifyNaming = document.getElementById('simplifyNaming');
        const replaceUuid = document.getElementById('replaceUuid');
        const addHideArmor = document.getElementById('addHideArmor');
        // æ–°å¢ï¼šé‡åæ¨¡å‹å…¼å®¹å¼€å…³
        const compatibleRenameModel = document.getElementById('compatibleRenameModel');
        // æ–°å¢ï¼šæ³¨é‡Šä¿®å¤å¼€å…³
        const fixComments = document.getElementById('fixComments');
        // æ–°å¢ï¼šè·å–mcpackè¾“å‡ºå¼€å…³
        const outputMcpack = document.getElementById('outputMcpack');
        // æ–°å¢ï¼šé¢„è®¾æŒ‰é’®å…ƒç´ 
        const presetButtons = document.querySelectorAll('.preset-btn');

        // åˆå§‹åŒ–ä¸Šä¼ åŒºåŸŸ
        [upload1, upload2].forEach((upload, index) => {
            upload.addEventListener('click', () => {
                index === 0 ? fileInput1.click() : fileInput2.click();
            });

            upload.addEventListener('dragover', (e) => {
                e.preventDefault();
                upload.classList.add('active');
            });

            upload.addEventListener('dragleave', () => {
                upload.classList.remove('active');
            });

            upload.addEventListener('drop', (e) => {
                e.preventDefault();
                upload.classList.remove('active');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    index === 0 ? handleFiles(files, skinPack1, fileList1) : handleFiles(files, skinPack2, fileList2);
                }
            });
        });

        // æ–‡ä»¶é€‰æ‹©äº‹ä»¶
        fileInput1.addEventListener('change', (e) => {
            handleFiles(e.target.files, skinPack1, fileList1);
        });

        fileInput2.addEventListener('change', (e) => {
            handleFiles(e.target.files, skinPack2, fileList2);
        });

        // æ–°å¢ï¼šé¢„è®¾æŒ‰é’®ç‚¹å‡»äº‹ä»¶ï¼ˆä¸æ”¹åŠ¨æ ¸å¿ƒä»£ç ï¼Œä»…æ·»åŠ é¢„è®¾é€»è¾‘ï¼‰
        presetButtons.forEach(button => {
            button.addEventListener('click', () => {
                const presetId = button.dataset.preset;
                const isActive = button.classList.contains('active');

                // åˆ‡æ¢é¢„è®¾çŠ¶æ€
                if (isActive) {
                    button.classList.remove('active');
                    logAdd(`âŒ å·²å…³é—­é¢„è®¾${presetId}ï¼š${presetConfigs[presetId].name}`);
                } else {
                    button.classList.add('active');
                    logAdd(`âœ… å·²å¯ç”¨é¢„è®¾${presetId}ï¼š${presetConfigs[presetId].name}`);
                }

                // åº”ç”¨æ‰€æœ‰æ¿€æ´»çš„é¢„è®¾é…ç½®ï¼ˆå¯å åŠ æ•ˆæœï¼‰
                applyPresets();
            });
        });

        // æ–°å¢ï¼šåº”ç”¨é¢„è®¾é…ç½®å‡½æ•°ï¼ˆåˆå¹¶æ‰€æœ‰æ¿€æ´»é¢„è®¾çš„è®¾ç½®ï¼‰
        function applyPresets() {
            const activePresets = document.querySelectorAll('.preset-btn.active');

            // å…ˆé‡ç½®æ‰€æœ‰å¼€å…³ä¸ºé»˜è®¤çŠ¶æ€ï¼ˆfalseï¼‰
            compatibleRenameModel.checked = false;
            simplifyNaming.checked = false;
            replaceUuid.checked = false;
            addHideArmor.checked = false;
            fixComments.checked = false;
            outputMcpack.checked = false;

            // éå†æ‰€æœ‰æ¿€æ´»çš„é¢„è®¾ï¼Œåº”ç”¨å…¶è®¾ç½®ï¼ˆå¯å åŠ ï¼‰
            activePresets.forEach(button => {
                const presetId = button.dataset.preset;
                const settings = presetConfigs[presetId].settings;

                Object.entries(settings).forEach(([key, value]) => {
                    const switchElement = document.getElementById(key);
                    if (switchElement) {
                        // åªè¦ä»»ä¸€æ¿€æ´»é¢„è®¾è¦æ±‚å¯ç”¨è¯¥é€‰é¡¹ï¼Œå°±è®¾ä¸ºtrue
                        if (value === true) {
                            switchElement.checked = true;
                        }
                    }
                });
            });

            // æ˜¾ç¤ºå½“å‰æ¿€æ´»çš„é¢„è®¾åˆ—è¡¨
            const activePresetNames = Array.from(activePresets).map(btn => presetConfigs[btn.dataset.preset].name);
            if (activePresetNames.length > 0) {
                logAdd(`ğŸ¯ å½“å‰æ¿€æ´»é¢„è®¾ï¼š${activePresetNames.join(', ')}`);
            }
        }

        // å¤„ç†ä¸Šä¼ çš„æ–‡ä»¶
        async function handleFiles(files, skinPack, fileListEl) {
            skinPack.files = {};
            skinPack.isZip = false;
            skinPack.name = '';
            skinPack.textureMap.clear();
            skinPack.geoRenameMap.clear();
            fileListEl.innerHTML = '';

            const zipFile = Array.from(files).find(file => file.name.endsWith('.zip'));
            if (zipFile) {
                skinPack.isZip = true;
                skinPack.name = getSafeFileName(zipFile.name.replace('.zip', ''));
                logAdd(`æ­£åœ¨è§£å‹ZIPåŒ…ï¼š${zipFile.name}`);
                await extractZip(zipFile, skinPack, fileListEl);
                logAdd(`âœ… è§£å‹å®Œæˆï¼Œå…±æ‰¾åˆ° ${Object.keys(skinPack.files).length} ä¸ªæ–‡ä»¶`);
            } else {
                if (files.length > 0) {
                    skinPack.name = getSafeFileName(files[0].name.split('.')[0]);
                }
                for (const file of files) {
                    const fileName = file.name.toLowerCase();
                    skinPack.files[fileName] = file;
                    addFileToFileList(fileListEl, file.name);
                }
                logAdd(`âœ… å·²æ·»åŠ  ${files.length} ä¸ªæ–‡ä»¶`);
            }

            updateMergeBtnStatus();
        }

        // ç”Ÿæˆå®‰å…¨çš„æ–‡ä»¶å
        function getSafeFileName(name) {
            return name.replace(/[\\/:*?"<>|]/g, '_').trim();
        }

        // ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„æ–‡ä»¶åï¼ˆæ–°å¢ï¼šæ ¹æ®å¼€å…³åˆ‡æ¢zip/mcpackåç¼€ï¼‰
        function getZipFileName() {
            const now = new Date();
            const timeStr = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}`;
            const name1 = skinPack1.name || 'skin1';
            const name2 = skinPack2.name || 'skin2';
            // æ–°å¢ï¼šæ ¹æ®å¼€å…³é€‰æ‹©åç¼€
            const suffix = outputMcpack.checked ? '.mcpack' : '.zip';
            return `merged_${name1}_${name2}_${timeStr}${suffix}`;
        }

        // ç”ŸæˆUUID v4
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // è§£å‹ZIPåŒ…
        async function extractZip(zipFile, skinPack, fileListEl) {
            try {
                const zip = new JSZip();
                const content = await zip.loadAsync(zipFile);

                for (const [relativePath, file] of Object.entries(content.files)) {
                    if (!file.dir) {
                        const fileName = relativePath.split('/').pop().toLowerCase();
                        const fileContent = await file.async('blob');
                        skinPack.files[fileName] = {
                            blob: fileContent,
                            name: fileName,
                            path: relativePath
                        };
                        addFileToFileList(fileListEl, relativePath);
                    }
                }
            } catch (error) {
                logAdd(`âŒ ZIPè§£å‹å¤±è´¥ï¼š${error.message}`);
                throw error;
            }
        }

        // æ·»åŠ æ–‡ä»¶åˆ°æ–‡ä»¶åˆ—è¡¨æ˜¾ç¤º
        function addFileToFileList(fileListEl, fileName) {
            const fileItem = document.createElement('div');
            fileItem.innerHTML = `<i class="fas fa-file"></i> ${fileName}`;
            fileListEl.appendChild(fileItem);
        }

        // æ›´æ–°åˆå¹¶æŒ‰é’®çŠ¶æ€
        function updateMergeBtnStatus() {
            const pack1Ready = hasCoreFiles(skinPack1.files);
            const pack2Ready = hasCoreFiles(skinPack2.files);
            mergeBtn.disabled = !pack1Ready || !pack2Ready || mergeInProgress;
        }

        // æ£€æŸ¥æ˜¯å¦åŒ…å«æ ¸å¿ƒæ–‡ä»¶
        function hasCoreFiles(files) {
            const coreFiles = ['manifest.json', 'geometry.json', 'skins.json'];
            return coreFiles.every(file => Object.keys(files).includes(file));
        }

        // å¤„ç†skins.jsonï¼Œç²¾å‡†åœ¨type: "free"å‰æ·»åŠ hide_armor: true
        function processSkinsForHideArmor(skins) {
            let modifiedCount = 0;

            // å¤„ç†æ¯ä¸ªçš®è‚¤æ¡ç›®
            skins.forEach((skin, skinIndex) => {
                // æ£€æŸ¥æ˜¯å¦å·²æœ‰hide_armor: trueï¼Œæœ‰åˆ™è·³è¿‡
                if (skin.hide_armor === true) {
                    return;
                }

                // æ£€æŸ¥æ˜¯å¦æœ‰type: "free"ï¼Œæ²¡æœ‰åˆ™è·³è¿‡
                if (skin.type !== "free") {
                    return;
                }

                // è·å–çš®è‚¤å¯¹è±¡çš„æ‰€æœ‰é”®ï¼Œä¿æŒåŸæœ‰é¡ºåºï¼ˆç°ä»£æµè§ˆå™¨ä¿éšœæ’å…¥é¡ºåºï¼‰
                const originalKeys = Object.keys(skin);
                // æ‰¾åˆ°typeé”®çš„ç´¢å¼•
                const typeKeyIndex = originalKeys.findIndex(key => key === 'type');

                // æ„å»ºæ–°çš„é”®æ•°ç»„ï¼šåœ¨typeå‰æ’å…¥hide_armor
                const newKeys = [
                    ...originalKeys.slice(0, typeKeyIndex),
                    'hide_armor',
                    ...originalKeys.slice(typeKeyIndex)
                ];

                // æ„å»ºæ–°çš„çš®è‚¤å¯¹è±¡ï¼Œä¸¥æ ¼æŒ‰æ–°é”®é¡ºåºèµ‹å€¼
                const newSkin = {};
                newKeys.forEach(key => {
                    if (key === 'hide_armor') {
                        newSkin[key] = true; // æ’å…¥hide_armor: true
                    } else {
                        newSkin[key] = skin[key]; // ä¿ç•™åŸæœ‰å­—æ®µå€¼
                    }
                });

                // æ›¿æ¢åŸçš®è‚¤å¯¹è±¡
                skins[skinIndex] = newSkin;
                modifiedCount++;

                logAdd(`ğŸ”„ å·²ä¸ºçš®è‚¤ "${skin.localization_name || 'æœªçŸ¥åç§°'}" å¯ç”¨éšè—ç›”ç”²ï¼ˆhide_armor: true æ”¾åœ¨type: "free"å‰ï¼‰`);
            });

            logAdd(`âœ… å…±ä¸º ${modifiedCount} ä¸ªçš®è‚¤å¯ç”¨éšè—ç›”ç”²ï¼ˆhide_armor: true å·²æ”¾åœ¨type: "free"å­—æ®µå‰ï¼‰`);
            return skins;
        }

        // ç§»é™¤JSONä¸­çš„//æ³¨é‡Šï¼ˆæ ¸å¿ƒï¼šå…ˆåˆ æ³¨é‡Šå†åˆå¹¶ï¼‰
        function removeComments(jsonStr) {
            // åŒ¹é…//æ³¨é‡Šï¼ˆä¸åŒ¹é…å­—ç¬¦ä¸²å†…çš„//ï¼‰+ å»é™¤ç©ºè¡Œ
            return jsonStr
                .replace(/(".*?")|(\/\/.*)/g, (match, str) => str || '')
                .replace(/^\s*[\r\n]/gm, '')
                .trim();
        }

        // æ—¥å¿—æ·»åŠ å‡½æ•°ï¼ˆè¡¥å…¨ç¼ºå¤±ï¼‰
        function logAdd(text) {
            const logItem = document.createElement('div');
            logItem.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
            log.appendChild(logItem);
            log.scrollTop = log.scrollHeight;
        }

        // æ›´æ–°è¿›åº¦å‡½æ•°ï¼ˆè¡¥å…¨ç¼ºå¤±ï¼‰
        function updateProgress(percent, text) {
            progressFill.style.width = `${percent}%`;
            progressText.innerHTML = `<i class="fas fa-spinner"></i> ${text}`;
        }

        // æ”¶é›†æ‰€æœ‰æ–‡ä»¶å‡½æ•°ï¼ˆè¡¥å…¨ç¼ºå¤±ï¼‰
        function collectAllFiles(mergedFiles, files1, files2, textureMap1, textureMap2, simplifyNaming) {
            const allFiles = { ...mergedFiles };

            // å¤„ç†ç¬¬ä¸€ä¸ªåŒ…çš„è´´å›¾æ–‡ä»¶
            for (const [fileName, file] of Object.entries(files1)) {
                if (fileName.endsWith('.png') || fileName.endsWith('.jpg') || fileName.endsWith('.jpeg')) {
                    const newFileName = textureMap1.get(fileName) || fileName;
                    allFiles[newFileName] = file;
                }
            }

            // å¤„ç†ç¬¬äºŒä¸ªåŒ…çš„è´´å›¾æ–‡ä»¶
            for (const [fileName, file] of Object.entries(files2)) {
                if (fileName.endsWith('.png') || fileName.endsWith('.jpg') || fileName.endsWith('.jpeg')) {
                    const newFileName = textureMap2.get(fileName) || fileName;
                    allFiles[newFileName] = file;
                }
            }

            return allFiles;
        }

        // ç”ŸæˆZIPå‡½æ•°ï¼ˆè¡¥å…¨ç¼ºå¤±ï¼‰
        async function generateZip(files) {
            const zip = new JSZip();
            for (const [fileName, file] of Object.entries(files)) {
                if (typeof file === 'string') {
                    zip.file(fileName, file);
                } else if (file.blob) {
                    zip.file(fileName, file.blob);
                } else {
                    zip.file(fileName, file);
                }
            }
            return await zip.generateAsync({ type: 'blob', compression: 'DEFLATE' });
        }

        // æ–°å¢ï¼šæ‰«ææ¨¡å‹-è´´å›¾-çš®è‚¤å…³è”å…³ç³»ï¼ˆé‡åå…¼å®¹æ ¸å¿ƒï¼‰
        function scanModelTextureRelations(coreData, packKey) {
            const relations = {
                modelToTextures: new Map(), // æ¨¡å‹å â†’ å…³è”è´´å›¾åˆ—è¡¨
                textureToModels: new Map(), // è´´å›¾å â†’ å…³è”æ¨¡å‹åˆ—è¡¨
                skinToModel: new Map(),     // çš®è‚¤å â†’ å…³è”æ¨¡å‹å
                skinToTexture: new Map(),    // çš®è‚¤å â†’ å…³è”è´´å›¾åï¼ˆç²¾å‡†åŒ¹é…ï¼‰
                skinTextureSuffix: new Map() // æ–°å¢ï¼šçš®è‚¤å â†’ è´´å›¾åç¼€ï¼ˆç”¨äºç”Ÿæˆå”¯ä¸€localization_nameï¼‰
            };

            // 1. æ‰«æskins.jsonï¼Œå»ºç«‹çš®è‚¤-æ¨¡å‹-è´´å›¾å…³è”
            coreData['skins.json'].skins.forEach((skin, skinIndex) => {
                const skinName = skin.localization_name || `skin_${skinIndex}`; // ç”¨ç´¢å¼•ä¿è¯å”¯ä¸€æ€§
                const modelName = skin.geometry;
                const textureName = skin.texture.toLowerCase();

                // çš®è‚¤â†’æ¨¡å‹
                relations.skinToModel.set(skinName, modelName);
                // æ–°å¢ï¼šçš®è‚¤â†’è´´å›¾ï¼ˆç²¾å‡†åŒ¹é…æ¯ä¸ªçš®è‚¤å¯¹åº”çš„è´´å›¾ï¼‰
                relations.skinToTexture.set(skinName, textureName);

                // æ¨¡å‹â†’è´´å›¾ï¼ˆå»é‡ï¼‰
                if (!relations.modelToTextures.has(modelName)) {
                    relations.modelToTextures.set(modelName, new Set());
                }
                relations.modelToTextures.get(modelName).add(textureName);

                // è´´å›¾â†’æ¨¡å‹ï¼ˆå»é‡ï¼‰
                if (!relations.textureToModels.has(textureName)) {
                    relations.textureToModels.set(textureName, new Set());
                }
                relations.textureToModels.get(textureName).add(modelName);
            });

            // 2. è½¬æ¢Setä¸ºArrayï¼Œæ–¹ä¾¿åç»­å¤„ç†
            for (const [model, textures] of relations.modelToTextures) {
                relations.modelToTextures.set(model, Array.from(textures));
            }
            for (const [texture, models] of relations.textureToModels) {
                relations.textureToModels.set(texture, Array.from(models));
            }

            // 3. å­˜å‚¨å…³è”å…³ç³»
            modelTextureRelations[packKey] = relations;
            logAdd(`ğŸ” æ‰«æ${packKey === 'pack1' ? 'ç¬¬ä¸€ä¸ª' : 'ç¬¬äºŒä¸ª'}çš®è‚¤åŒ…å…³è”å…³ç³»ï¼š`);
            logAdd(`   - æ¨¡å‹æ•°ï¼š${relations.modelToTextures.size} | è´´å›¾æ•°ï¼š${relations.textureToModels.size} | çš®è‚¤æ•°ï¼š${relations.skinToModel.size}`);

            // 4. è¾“å‡ºå…±ç”¨æƒ…å†µæ—¥å¿—
            for (const [model, textures] of relations.modelToTextures) {
                if (textures.length > 1) {
                    logAdd(`   âš ï¸ æ¨¡å‹ã€${model}ã€‘å…³è”å¤šä¸ªè´´å›¾ï¼š${textures.join(', ')}`);
                }
            }
            for (const [texture, models] of relations.textureToModels) {
                if (models.length > 1) {
                    logAdd(`   âš ï¸ è´´å›¾ã€${texture}ã€‘å…³è”å¤šä¸ªæ¨¡å‹ï¼š${models.join(', ')}`);
                }
            }

            return relations;
        }

        // ä¿®å¤ï¼šé‡åæ¨¡å‹å…¼å®¹çš„å‘½åç®€åŒ–ï¼ˆæ ¸å¿ƒä¿®å¤é€»è¾‘ï¼‰
        function compatibleSimplifyEntries(core, packKey, startIndex) {
            const relations = modelTextureRelations[packKey];
            const modifiedSkins = [];
            const geoRenameMap = new Map(); // åŸgeoå â†’ æ–°geoå
            const textureMap = new Map();   // åŸè´´å›¾å â†’ æ–°è´´å›¾å
            // æ–°å¢ï¼šè®°å½•æ¯ä¸ªæ¨¡å‹ä¸‹çš„è´´å›¾åç¼€æ˜ å°„ï¼ˆç”¨äºç”Ÿæˆå”¯ä¸€localization_nameï¼‰
            const modelTextureSuffixMap = new Map();

            // ç¬¬ä¸€æ­¥ï¼šé¢„å¤„ç† - æ ‡è®°ç‰¹æ®Šåœºæ™¯ï¼ˆå¤šè´´å›¾/å¤šæ¨¡å‹ï¼‰
            const modelHasMultiTextures = new Map(); // æ¨¡å‹å â†’ è´´å›¾åˆ—è¡¨ï¼ˆå¤šè´´å›¾ï¼‰
            const textureHasMultiModels = new Map(); // è´´å›¾å â†’ æ¨¡å‹åˆ—è¡¨ï¼ˆå¤šæ¨¡å‹ï¼‰

            // è¯†åˆ«ä¸€ä¸ªæ¨¡å‹å¯¹åº”å¤šä¸ªè´´å›¾çš„åœºæ™¯
            for (const [modelName, textures] of relations.modelToTextures) {
                if (textures.length > 1) {
                    modelHasMultiTextures.set(modelName, textures);
                    logAdd(`ğŸ“Œ æ¨¡å‹ã€${modelName}ã€‘å…³è”å¤šä¸ªè´´å›¾ï¼Œå°†ä¿ç•™æ¨¡å‹åï¼Œä¿®æ”¹è´´å›¾å`);
                    // ä¸ºè¯¥æ¨¡å‹çš„æ¯ä¸ªè´´å›¾åˆ†é…åç¼€
                    const suffixMap = new Map();
                    textures.forEach((texture, idx) => {
                        suffixMap.set(texture, idx === 0 ? '' : `_${idx + 1}`);
                    });
                    modelTextureSuffixMap.set(modelName, suffixMap);
                }
            }

            // è¯†åˆ«ä¸€ä¸ªè´´å›¾å¯¹åº”å¤šä¸ªæ¨¡å‹çš„åœºæ™¯
            for (const [textureName, models] of relations.textureToModels) {
                if (models.length > 1) {
                    textureHasMultiModels.set(textureName, models);
                    logAdd(`ğŸ“Œ è´´å›¾ã€${textureName}ã€‘å…³è”å¤šä¸ªæ¨¡å‹ï¼Œå°†ä¿ç•™è´´å›¾åï¼Œä¿®æ”¹æ¨¡å‹å`);
                }
            }

            // ç¬¬äºŒæ­¥ï¼šåŸºç¡€å‘½åæ˜ å°„ï¼ˆå…ˆå¤„ç†ä¸€å¯¹ä¸€åœºæ™¯ï¼‰
            const modelNewNameMap = new Map(); // åŸæ¨¡å‹å â†’ æ–°æ¨¡å‹å
            const textureNewNameMap = new Map(); // åŸè´´å›¾å â†’ æ–°è´´å›¾å
            let baseIndex = startIndex;

            // å…ˆä¸ºæ— å†²çªçš„æ¨¡å‹/è´´å›¾åˆ†é…åŸºç¡€åç§°
            for (const [modelName] of relations.modelToTextures) {
                if (!modelHasMultiTextures.has(modelName) && !Array.from(textureHasMultiModels.values()).some(models => models.includes(modelName))) {
                    if (!modelNewNameMap.has(modelName)) {
                        const newModelName = `geometry.skin${baseIndex}`;
                        modelNewNameMap.set(modelName, newModelName);
                        geoRenameMap.set(modelName, newModelName);

                        // ä¸€å¯¹ä¸€åœºæ™¯ï¼šè´´å›¾åè·Ÿéšæ¨¡å‹å
                        const textures = relations.modelToTextures.get(modelName);
                        if (textures.length === 1) {
                            const textureName = textures[0];
                            const newTextureName = `skin${baseIndex}.png`.toLowerCase();
                            textureNewNameMap.set(textureName, newTextureName);
                            textureMap.set(textureName, newTextureName);
                        }
                        baseIndex++;
                    }
                }
            }

            // ç¬¬ä¸‰æ­¥ï¼šå¤„ç†ç‰¹æ®Šåœºæ™¯1 - ä¸€ä¸ªæ¨¡å‹å¯¹åº”å¤šä¸ªè´´å›¾ï¼ˆæ ¸å¿ƒä¿®å¤ï¼‰
            // è§„åˆ™ï¼šåŒä¸€æ¨¡å‹çš„æ‰€æœ‰çš®è‚¤å…±ç”¨åŒä¸€ä¸ªæ–°æ¨¡å‹åï¼Œè´´å›¾æŒ‰é¡ºåºåŠ åç¼€
            for (const [modelName, textures] of modelHasMultiTextures) {
                // ä¸ºæ¨¡å‹åˆ†é…åŸºç¡€åç§°ï¼ˆæ‰€æœ‰çš®è‚¤å…±ç”¨è¿™ä¸ªæ¨¡å‹åï¼‰
                if (!modelNewNameMap.has(modelName)) {
                    const newModelName = `geometry.skin${baseIndex}`;
                    modelNewNameMap.set(modelName, newModelName);
                    geoRenameMap.set(modelName, newModelName);
                    logAdd(`ğŸ”§ æ¨¡å‹ã€${modelName}ã€‘ç»Ÿä¸€é‡å‘½åä¸ºï¼š${newModelName}`);

                    // ä¸ºè¯¥æ¨¡å‹ä¸‹çš„æ¯ä¸ªè´´å›¾æŒ‰é¡ºåºåˆ†é…æ–°åç§°
                    const baseTextureName = `skin${baseIndex}`;
                    textures.forEach((textureName, idx) => {
                        if (!textureNewNameMap.has(textureName)) {
                            // ç¬¬ä¸€ä¸ªè´´å›¾ç”¨åŸºç¡€åï¼Œåç»­åŠ åç¼€ï¼ˆ_2ã€_3...ï¼‰
                            const suffix = idx === 0 ? '' : `_${idx + 1}`;
                            const newTextureName = `${baseTextureName}${suffix}.png`.toLowerCase();
                            textureNewNameMap.set(textureName, newTextureName);
                            textureMap.set(textureName, newTextureName);
                            // è®°å½•è¯¥æ¨¡å‹ä¸‹æ­¤è´´å›¾çš„åç¼€ï¼ˆç”¨äºç”Ÿæˆlocalization_nameï¼‰
                            if (!modelTextureSuffixMap.has(modelName)) {
                                modelTextureSuffixMap.set(modelName, new Map());
                            }
                            modelTextureSuffixMap.get(modelName).set(textureName, suffix);
                            logAdd(`ğŸ”§ æ¨¡å‹ã€${modelName}ã€‘çš„è´´å›¾ã€${textureName}ã€‘â†’ ${newTextureName}ï¼ˆç¬¬${idx + 1}ä¸ªè´´å›¾ï¼‰`);
                        }
                    });
                    baseIndex++;
                }
            }

            // ç¬¬å››æ­¥ï¼šå¤„ç†ç‰¹æ®Šåœºæ™¯2 - ä¸€ä¸ªè´´å›¾å¯¹åº”å¤šä¸ªæ¨¡å‹ï¼ˆä¿ç•™è´´å›¾åï¼Œæ”¹æ¨¡å‹åï¼‰
            for (const [textureName, models] of textureHasMultiModels) {
                // ä¸ºè´´å›¾åˆ†é…åŸºç¡€åç§°ï¼ˆä¿ç•™ï¼‰
                if (!textureNewNameMap.has(textureName)) {
                    const baseTextureName = `skin${baseIndex}`;
                    const newTextureName = `${baseTextureName}.png`.toLowerCase();
                    textureNewNameMap.set(textureName, newTextureName);
                    textureMap.set(textureName, newTextureName);
                    logAdd(`ğŸ”§ è´´å›¾ã€${textureName}ã€‘åŸºç¡€åç§°ï¼š${newTextureName}`);
                }
                const baseTextureName = textureNewNameMap.get(textureName).replace('.png', '');

                // ä¸ºæ¯ä¸ªæ¨¡å‹ç”Ÿæˆå”¯ä¸€åç¼€
                models.forEach((modelName, idx) => {
                    if (!modelNewNameMap.has(modelName)) {
                        const suffix = idx === 0 ? '' : `_${idx + 1}`;
                        const newModelName = `geometry.${baseTextureName}${suffix}`;
                        modelNewNameMap.set(modelName, newModelName);
                        geoRenameMap.set(modelName, newModelName);
                        // è®°å½•è¯¥è´´å›¾ä¸‹æ­¤æ¨¡å‹çš„åç¼€ï¼ˆç”¨äºç”Ÿæˆlocalization_nameï¼‰
                        if (!modelTextureSuffixMap.has(modelName)) {
                            modelTextureSuffixMap.set(modelName, new Map());
                        }
                        modelTextureSuffixMap.get(modelName).set(textureName, suffix);
                        logAdd(`ğŸ”§ æ¨¡å‹ã€${modelName}ã€‘â†’ ${newModelName}ï¼ˆè´´å›¾${textureName}çš„ç¬¬${idx + 1}ä¸ªæ¨¡å‹ï¼‰`);
                    }
                });
                baseIndex++;
            }

            // ç¬¬äº”æ­¥ï¼šæ›´æ–°çš®è‚¤ä¿¡æ¯ï¼ˆæ ¸å¿ƒä¿®å¤ï¼šç²¾å‡†åŒ¹é…æ¯ä¸ªçš®è‚¤çš„è´´å›¾ + ç”Ÿæˆå”¯ä¸€localization_nameï¼‰
            core['skins.json'].skins.forEach((skin, index) => {
                const skinName = skin.localization_name || `skin_${index}`;
                const oldModelName = skin.geometry;
                const oldTextureName = relations.skinToTexture.get(skinName); // ä»å…³è”è¡¨è·å–ç²¾å‡†è´´å›¾å

                // è·å–æ–°åç§°ï¼ˆä¿è¯åŒä¸€æ¨¡å‹çš„æ‰€æœ‰çš®è‚¤ç”¨åŒä¸€ä¸ªæ–°æ¨¡å‹åï¼‰
                const newModelName = modelNewNameMap.get(oldModelName) || oldModelName;
                const newTextureName = textureNewNameMap.get(oldTextureName) || oldTextureName;

                // æ ¸å¿ƒä¿®å¤ï¼šç”Ÿæˆå”¯ä¸€çš„localization_nameï¼ˆç»“åˆæ¨¡å‹å+è´´å›¾åç¼€ï¼‰
                let newSkinName = newModelName.replace('geometry.', '');
                // è·å–è¯¥çš®è‚¤å¯¹åº”çš„è´´å›¾åç¼€
                if (modelTextureSuffixMap.has(oldModelName) && modelTextureSuffixMap.get(oldModelName).has(oldTextureName)) {
                    const suffix = modelTextureSuffixMap.get(oldModelName).get(oldTextureName);
                    newSkinName += suffix;
                }

                const modifiedSkin = {
                    ...skin,
                    localization_name: newSkinName, // ä¿®å¤ï¼šç¡®ä¿localization_nameå”¯ä¸€
                    geometry: newModelName,
                    texture: newTextureName
                };
                modifiedSkins.push(modifiedSkin);

                logAdd(`ğŸ”„ å…¼å®¹é‡å‘½åï¼šçš®è‚¤ã€${skinName}ã€‘â†’ã€${newSkinName}ã€‘`);
                logAdd(`   â†³ æ¨¡å‹ã€${oldModelName}ã€‘â†’ã€${newModelName}ã€‘ | è´´å›¾ã€${oldTextureName}ã€‘â†’ã€${newTextureName}ã€‘`);
                logAdd(`   â†³ localization_nameï¼š${skin.localization_name || 'æœªçŸ¥'} â†’ ${newSkinName}`);
            });

            return {
                modifiedSkins,
                geoRenameMap,
                textureMap
            };
        }

        // åˆå¹¶æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        mergeBtn.addEventListener('click', async () => {
            if (mergeInProgress) return;
            mergeInProgress = true;
            mergeBtn.disabled = true;
            progress.style.display = 'block';
            result.style.display = 'none';
            logAdd('=== å¼€å§‹åˆå¹¶çš®è‚¤åŒ… ===');

            // æ–°å¢ï¼šæ˜¾ç¤ºå½“å‰é¢„è®¾åº”ç”¨çŠ¶æ€
            const activePresets = document.querySelectorAll('.preset-btn.active');
            if (activePresets.length > 0) {
                const activeNames = Array.from(activePresets).map(btn => presetConfigs[btn.dataset.preset].name);
                logAdd(`ğŸ¯ å½“å‰æ¿€æ´»é¢„è®¾ï¼š${activeNames.join(', ')}`);
            }

            logAdd(`é‡åæ¨¡å‹å…¼å®¹: ${compatibleRenameModel.checked ? 'å·²å¯ç”¨ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰' : 'å·²ç¦ç”¨'}`);
            logAdd(`å‘½åç®€åŒ–åŠŸèƒ½: ${simplifyNaming.checked ? 'å·²å¯ç”¨' : 'å·²ç¦ç”¨'}`);
            logAdd(`UUIDæ›¿æ¢åŠŸèƒ½: ${replaceUuid.checked ? 'å·²å¯ç”¨' : 'å·²ç¦ç”¨'}`);
            logAdd(`éšè—ç›”ç”²åŠŸèƒ½: ${addHideArmor.checked ? 'å·²å¯ç”¨' : 'å·²ç¦ç”¨'}`);
            logAdd(`æ³¨é‡Šä¿®å¤åŠŸèƒ½: ${fixComments.checked ? 'å·²å¯ç”¨' : 'å·²ç¦ç”¨'}`);
            logAdd(`è¾“å‡ºæ ¼å¼: ${outputMcpack.checked ? 'mcpack (.mcpack)' : 'ZIP (.zip)'}`);

            try {
                updateProgress(20, 'åŠ è½½æ ¸å¿ƒæ–‡ä»¶...');
                const core1 = await loadCoreFiles(skinPack1.files, 'ç¬¬ä¸€ä¸ª');
                const core2 = await loadCoreFiles(skinPack2.files, 'ç¬¬äºŒä¸ª');

                // æ–°å¢ï¼šæ‰«ææ¨¡å‹-è´´å›¾å…³è”å…³ç³»ï¼ˆæ— è®ºæ˜¯å¦å¯ç”¨å…¼å®¹ï¼Œå…ˆæ‰«æï¼‰
                updateProgress(25, 'æ‰«ææ¨¡å‹-è´´å›¾å…³è”å…³ç³»...');
                scanModelTextureRelations(core1, 'pack1');
                scanModelTextureRelations(core2, 'pack2');

                updateProgress(40, compatibleRenameModel.checked ? 'æ‰§è¡Œé‡åæ¨¡å‹å…¼å®¹å‘½å...' : (simplifyNaming.checked ? 'æ‰§è¡Œå‘½åç®€åŒ–...' : 'å¤„ç†é‡å¤å­—æ®µ...'));
                let modifiedSkins1 = [...core1['skins.json'].skins]; // ç¬¬ä¸€ä¸ªåŒ…çš„çš®è‚¤ï¼ˆå¯èƒ½ä¿®æ”¹ï¼‰
                let modifiedSkins2 = [];                            // ç¬¬äºŒä¸ªåŒ…çš„çš®è‚¤ï¼ˆä¿®æ”¹åï¼‰
                let geoRenameMap1 = new Map();                      // ç¬¬ä¸€ä¸ªåŒ…geoé‡å‘½åæ˜ å°„
                let geoRenameMap2 = new Map();                      // ç¬¬äºŒä¸ªåŒ…geoé‡å‘½åæ˜ å°„
                let textureMap1 = new Map();                        // ç¬¬ä¸€ä¸ªåŒ…è´´å›¾æ˜ å°„
                let textureMap2 = new Map();                        // ç¬¬äºŒä¸ªåŒ…è´´å›¾æ˜ å°„

                if (compatibleRenameModel.checked) {
                    // æ–°å¢ï¼šå¯ç”¨é‡åæ¨¡å‹å…¼å®¹ï¼ˆä¼˜å…ˆçº§é«˜äºå‘½åç®€åŒ–ï¼‰
                    const simplifyResult1 = compatibleSimplifyEntries(core1, 'pack1', 0);
                    modifiedSkins1 = simplifyResult1.modifiedSkins;
                    geoRenameMap1 = simplifyResult1.geoRenameMap;
                    textureMap1 = simplifyResult1.textureMap;

                    const totalSkins1 = modifiedSkins1.length;
                    const simplifyResult2 = compatibleSimplifyEntries(core2, 'pack2', totalSkins1);
                    modifiedSkins2 = simplifyResult2.modifiedSkins;
                    geoRenameMap2 = simplifyResult2.geoRenameMap;
                    textureMap2 = simplifyResult2.textureMap;
                } else if (simplifyNaming.checked) {
                    // åŸæœ‰ï¼šå‘½åç®€åŒ–æ¨¡å¼
                    const simplifyResult1 = simplifySinglePackEntries(core1, 0);
                    modifiedSkins1 = simplifyResult1.modifiedSkins;
                    geoRenameMap1 = simplifyResult1.geoRenameMap;
                    textureMap1 = simplifyResult1.textureMap;

                    const totalSkins1 = modifiedSkins1.length;
                    const simplifyResult2 = simplifySinglePackEntries(core2, totalSkins1);
                    modifiedSkins2 = simplifyResult2.modifiedSkins;
                    geoRenameMap2 = simplifyResult2.geoRenameMap;
                    textureMap2 = simplifyResult2.textureMap;
                } else {
                    // åŸæœ‰ï¼šæ™®é€šæ¨¡å¼
                    const duplicateResult = modifyDuplicateEntries(core1, core2);
                    modifiedSkins2 = duplicateResult.modifiedSkins;
                    geoRenameMap2 = duplicateResult.geoRenameMap;

                    core2['skins.json'].skins.forEach((skin, index) => {
                        textureMap2.set(skin.texture.toLowerCase(), modifiedSkins2[index].texture.toLowerCase());
                    });
                }

                // ä¿å­˜æ˜ å°„è¡¨åˆ°å…¨å±€
                skinPack1.geoRenameMap = geoRenameMap1;
                skinPack1.textureMap = textureMap1;
                skinPack2.geoRenameMap = geoRenameMap2;
                skinPack2.textureMap = textureMap2;

                // åˆå¹¶æ‰€æœ‰çš®è‚¤
                let allModifiedSkins = [...modifiedSkins1, ...modifiedSkins2];

                // å¦‚æœå¯ç”¨äº†éšè—ç›”ç”²åŠŸèƒ½ï¼Œåˆ™å¤„ç†çš®è‚¤
                if (addHideArmor.checked) {
                    updateProgress(50, 'å¤„ç†éšè—ç›”ç”²é…ç½®...');
                    allModifiedSkins = processSkinsForHideArmor(allModifiedSkins);
                }

                updateProgress(60, 'åˆå¹¶æ ¸å¿ƒæ–‡ä»¶...');
                const mergedFiles = mergeCoreFiles(core1, core2, allModifiedSkins, geoRenameMap1, geoRenameMap2);

                updateProgress(70, 'æ”¶é›†è´´å›¾æ–‡ä»¶...');
                const allFiles = collectAllFiles(mergedFiles, skinPack1.files, skinPack2.files,
                    textureMap1, textureMap2, simplifyNaming.checked);

                updateProgress(80, 'ç”Ÿæˆå‹ç¼©åŒ…...'); // è°ƒæ•´æ–‡å­—ï¼šZIP â†’ å‹ç¼©åŒ…
                const zipFileName = getZipFileName();
                const zipBlob = await generateZip(allFiles);

                updateProgress(100, 'åˆå¹¶å®Œæˆï¼');
                logAdd(`ğŸ‰ åˆå¹¶æˆåŠŸï¼ç”Ÿæˆæ–‡ä»¶ï¼š${zipFileName}`);
                logAdd('â¤ï¸ å…³æ³¨bç«™fangkuaichaogeå–µï¼Œå…³æ³¨fangkuaichaogeè°¢è°¢å–µ');
                result.style.display = 'block';
                // æ–°å¢ï¼šæ›´æ–°ä¸‹è½½æŒ‰é’®æ–‡å­—ï¼ˆé€‚é…mcpackï¼‰
                downloadBtn.innerHTML = `<i class="fas fa-download"></i> ä¸‹è½½åˆå¹¶åçš„${outputMcpack.checked ? 'mcpackæ–‡ä»¶' : 'ZIPæ–‡ä»¶'}`;
                downloadBtn.onclick = () => {
                    saveAs(zipBlob, zipFileName);
                };
            } catch (error) {
                logAdd(`âŒ åˆå¹¶å¤±è´¥ï¼š${error.message}`);
                logAdd(`é”™è¯¯è¯¦æƒ…ï¼š${error.stack || JSON.stringify(error)}`);
            } finally {
                mergeInProgress = false;
                mergeBtn.disabled = !hasCoreFiles(skinPack1.files) || !hasCoreFiles(skinPack2.files);
            }
        });

        // åŠ è½½å¹¶è§£ææ ¸å¿ƒJSONæ–‡ä»¶ï¼ˆæ ¸å¿ƒï¼šå…ˆåˆ æ³¨é‡Šå†è§£æï¼‰
        async function loadCoreFiles(files, packName) {
            const coreFiles = ['manifest.json', 'geometry.json', 'skins.json'];
            const coreData = {};

            for (const fileName of coreFiles) {
                const file = files[fileName];
                if (!file) throw new Error(`${packName}çš®è‚¤åŒ…ç¼ºå°‘æ ¸å¿ƒæ–‡ä»¶ï¼š${fileName}`);

                let content;
                if (file.blob) {
                    content = await new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (e) => resolve(e.target.result);
                        reader.readAsText(file.blob);
                    });
                } else {
                    content = await new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (e) => resolve(e.target.result);
                        reader.readAsText(file);
                    });
                }

                try {
                    // ä»…åœ¨å¼€å…³å¼€å¯æ—¶åˆ é™¤æ³¨é‡Š
                    if (fixComments.checked) {
                        logAdd(`ğŸ”§ ç§»é™¤${packName}çš®è‚¤åŒ…${fileName}ä¸­çš„//æ³¨é‡Š`);
                        content = removeComments(content);
                    }

                    coreData[fileName] = JSON.parse(content);
                    logAdd(`âœ… æˆåŠŸåŠ è½½${packName}çš®è‚¤åŒ…çš„${fileName}`);
                } catch (error) {
                    logAdd(`âš ï¸ ${packName}çš®è‚¤åŒ…çš„${fileName}è¯­æ³•é”™è¯¯ï¼Œå°è¯•è‡ªåŠ¨ä¿®å¤...`);
                    const fixedContent = fixJsonSyntax(content);
                    try {
                        coreData[fileName] = JSON.parse(fixedContent);
                        logAdd(`âœ… ${fileName}ä¿®å¤æˆåŠŸ`);
                    } catch (error2) {
                        throw new Error(`${fileName}ä¿®å¤å¤±è´¥ï¼š${error2.message}`);
                    }
                }
            }

            return coreData;
        }

        // ä¿®å¤JSONè¯­æ³•é”™è¯¯
        function fixJsonSyntax(jsonStr) {
            jsonStr = jsonStr.replace(/,\s*}/g, '}');
            jsonStr = jsonStr.replace(/,\s*]/g, ']');
            jsonStr = jsonStr.replace(/(?<!\\)'/g, '"');
            jsonStr = jsonStr.replace(/([{,]\s*)(\w+)(\s*:)/g, '$1"$2"$3');
            return jsonStr;
        }

        // å‘½åç®€åŒ–ï¼šå¤„ç†å•ä¸ªåŒ…çš„å‘½åï¼ˆä»æŒ‡å®šç´¢å¼•å¼€å§‹ï¼‰
        function simplifySinglePackEntries(core, startIndex) {
            const modifiedSkins = [];
            const geoRenameMap = new Map(); // åŸgeoå â†’ æ–°geoå
            const textureMap = new Map();   // åŸè´´å›¾å â†’ æ–°è´´å›¾å

            core['skins.json'].skins.forEach((skin, index) => {
                const baseName = `skin${startIndex + index}`;
                const newGeometryName = `geometry.${baseName}`;
                const newTextureName = `${baseName}.png`.toLowerCase();

                // ä¿å­˜æ˜ å°„å…³ç³»
                geoRenameMap.set(skin.geometry, newGeometryName);
                textureMap.set(skin.texture.toLowerCase(), newTextureName);

                // ä¿®æ”¹çš®è‚¤ä¿¡æ¯ï¼ˆç¡®ä¿localization_nameå”¯ä¸€ï¼‰
                const modifiedSkin = {
                    ...skin,
                    localization_name: baseName, // æ˜ç¡®èµ‹å€¼ï¼Œç¡®ä¿ä¿®æ”¹ç”Ÿæ•ˆ
                    geometry: newGeometryName,
                    texture: newTextureName
                };
                modifiedSkins.push(modifiedSkin);
                logAdd(`ğŸ”„ ç®€åŒ–å‘½åï¼š${skin.localization_name} â†’ ${baseName}`);
                logAdd(`ğŸ”„ Geometryé‡å‘½åï¼š${skin.geometry} â†’ ${newGeometryName}`);
                logAdd(`ğŸ”„ è´´å›¾é‡å‘½åï¼š${skin.texture} â†’ ${newTextureName}`);
            });

            return {
                modifiedSkins,
                geoRenameMap,
                textureMap
            };
        }

        // åŸæœ‰ï¼šå¤„ç†é‡å¤å­—æ®µ
        function modifyDuplicateEntries(core1, core2) {
            const firstLocalization = new Set(core1['skins.json'].skins.map(skin => skin.localization_name));
            const firstGeometry = new Set(core1['skins.json'].skins.map(skin => skin.geometry));
            const firstTexture = new Set(core1['skins.json'].skins.map(skin => skin.texture));

            const secondLocalization = new Set(core2['skins.json'].skins.map(skin => skin.localization_name));
            const secondGeometryKeys = new Set(Object.keys(core2['geometry.json']));
            const secondTexture = new Set(core2['skins.json'].skins.map(skin => skin.texture));

            const allLocalization = new Set([...firstLocalization, ...secondLocalization]);
            const allGeometry = new Set([...firstGeometry, ...secondGeometryKeys]);
            const allTexture = new Set([...firstTexture, ...secondTexture]);

            const modifiedSkins = [];
            const geoRenameMap = new Map();

            for (const skin of core2['skins.json'].skins) {
                const isDuplicate = (
                    allLocalization.has(skin.localization_name) ||
                    allGeometry.has(skin.geometry) ||
                    allTexture.has(skin.texture)
                );

                if (isDuplicate) {
                    const locSuffix = getUniqueSuffix(skin.localization_name, allLocalization);
                    const geoSuffix = getUniqueSuffix(skin.geometry, allGeometry);
                    const texSuffix = locSuffix;

                    const textureParts = skin.texture.split('.');
                    const textureName = textureParts[0];
                    const textureExt = textureParts.length > 1 ? textureParts.slice(1).join('.') : '';

                    const modifiedSkin = { ...skin };
                    modifiedSkin.localization_name = skin.localization_name + locSuffix; // æ˜ç¡®èµ‹å€¼ï¼Œç¡®ä¿ä¿®æ”¹ç”Ÿæ•ˆ
                    modifiedSkin.geometry += geoSuffix;
                    modifiedSkin.texture = textureExt ? `${textureName}${texSuffix}.${textureExt}` : `${textureName}${texSuffix}`;

                    allLocalization.add(modifiedSkin.localization_name);
                    allGeometry.add(modifiedSkin.geometry);
                    allTexture.add(modifiedSkin.texture);

                    modifiedSkins.push(modifiedSkin);
                    geoRenameMap.set(skin.geometry, modifiedSkin.geometry);
                    logAdd(`âš ï¸ é‡å¤å­—æ®µå·²ä¿®æ”¹ï¼š${skin.localization_name} â†’ ${modifiedSkin.localization_name}`);
                } else {
                    modifiedSkins.push(skin);
                    geoRenameMap.set(skin.geometry, skin.geometry);
                }
            }

            return { modifiedSkins, geoRenameMap };
        }

        // ç”Ÿæˆå”¯ä¸€åç¼€
        function getUniqueSuffix(base, existingSet) {
            let suffix = '_2';
            while (existingSet.has(base + suffix)) {
                suffix = `_${parseInt(suffix.slice(1)) + 1}`;
            }
            return suffix;
        }

        // åˆå¹¶æ ¸å¿ƒæ–‡ä»¶
        function mergeCoreFiles(core1, core2, allModifiedSkins, geoRenameMap1, geoRenameMap2) {
            const mergedFiles = {};

            // 1. åˆå¹¶manifest.json
            let manifest = { ...core1['manifest.json'] };

            if (replaceUuid.checked) {
                const uuid1 = generateUUID();
                const uuid2 = generateUUID();

                if (manifest.header && manifest.header.uuid) {
                    logAdd(`ğŸ”„ æ›¿æ¢header UUID: ${manifest.header.uuid} â†’ ${uuid1}`);
                    manifest.header.uuid = uuid1;
                }
                if (manifest.modules && manifest.modules.length > 0 && manifest.modules[0].uuid) {
                    logAdd(`ğŸ”„ æ›¿æ¢module UUID: ${manifest.modules[0].uuid} â†’ ${uuid2}`);
                    manifest.modules[0].uuid = uuid2;
                }
            }

            mergedFiles['manifest.json'] = JSON.stringify(manifest);
            logAdd('âœ… åˆå¹¶manifest.jsonå®Œæˆï¼ˆä¿ç•™ç¬¬ä¸€ä¸ªåŒ…é…ç½®ï¼‰');

            // 2. åˆå¹¶geometry.json
            const core1GeoMerged = {};
            for (const [oldKey, geoData] of Object.entries(core1['geometry.json'])) {
                const newKey = geoRenameMap1.get(oldKey) || oldKey;
                core1GeoMerged[newKey] = geoData;
            }

            const core2GeoMerged = {};
            for (const [oldKey, geoData] of Object.entries(core2['geometry.json'])) {
                const newKey = geoRenameMap2.get(oldKey) || oldKey;
                core2GeoMerged[newKey] = geoData;
            }

            const mergedGeo = { ...core1GeoMerged, ...core2GeoMerged };
            let geoStr = JSON.stringify(mergedGeo);
            const lastBraceIndex = geoStr.lastIndexOf('}');
            geoStr = geoStr.substring(0, lastBraceIndex) + ',' + geoStr.substring(lastBraceIndex);
            mergedFiles['geometry.json'] = geoStr;
            logAdd('âœ… åˆå¹¶geometry.jsonå®Œæˆï¼ˆåˆå¹¶ä¸¤ä¸ªåŒ…çš„å‡ ä½•æ•°æ®ï¼‰');

            // 3. åˆå¹¶skins.json
            mergedFiles['skins.json'] = JSON.stringify({ skins: allModifiedSkins });
            logAdd(`âœ… åˆå¹¶skins.jsonå®Œæˆï¼ˆå…± ${allModifiedSkins.length} ä¸ªçš®è‚¤ï¼‰`);

            return mergedFiles;
        }
    </script>
</body>

</html>
