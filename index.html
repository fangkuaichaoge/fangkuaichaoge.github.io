<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft 4Dçš®è‚¤åŒ…åˆå¹¶å·¥å…·</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @font-face {
            font-family: 'Minecraft';
            src: local('Microsoft YaHei'), local('SimHei'), sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --mc-green: #3b8526;
            --mc-green-hover: #4a9b30;
            --mc-gray-light: #d0d1d5;
            --mc-bg-dark: #1b1b1b;
            --mc-bg-panel: #212121;
            --mc-bg-button: #404040;
            --mc-border: #000000;
            --mc-text-muted: #888888;
            --mc-red: #8b3a3a;
            --mc-red-hover: #a04545;
        }

        body {
            font-family: "Microsoft YaHei", sans-serif;
            background-color: var(--mc-bg-dark);
            color: var(--mc-gray-light);
            min-height: 100vh;
            display: flex;
            overflow-x: hidden;
            image-rendering: pixelated;
        }

        /* å·¦ä¾§è¾¹æ  - Minecrafté£æ ¼ */
        .sidebar {
            width: 80px;
            background-color: var(--mc-bg-panel);
            border-right: 4px solid var(--mc-border);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
            box-shadow: 4px 0 0 rgba(0,0,0,0.5);
            position: fixed;
            height: 100vh;
            z-index: 100;
        }

        .logo {
            width: 48px;
            height: 48px;
            background-color: var(--mc-green);
            border: 3px solid var(--mc-border);
            border-bottom: 6px solid var(--mc-border);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--mc-gray-light);
            font-size: 20px;
            image-rendering: pixelated;
            box-shadow: inset 0 2px 0 rgba(255,255,255,0.2);
        }

        .version {
            margin-top: auto;
            color: var(--mc-text-muted);
            font-size: 12px;
            font-weight: 600;
            text-shadow: 2px 2px 0 #000;
        }

        /* ä¸»å†…å®¹åŒº */
        .main-content {
            flex: 1;
            margin-left: 80px;
            padding: 30px;
            max-width: 1200px;
        }

        .page-header {
            margin-bottom: 24px;
            text-align: center;
            border-bottom: 3px solid var(--mc-border);
            padding-bottom: 16px;
            background-color: rgba(0,0,0,0.2);
            padding: 16px;
            border: 3px solid var(--mc-border);
            box-shadow: 0 4px 0 rgba(0,0,0,0.5);
        }

        .page-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--mc-gray-light);
            display: inline-flex;
            align-items: center;
            gap: 12px;
            text-shadow: 2px 2px 0 #000;
        }

        .page-title i {
            color: var(--mc-green);
            font-size: 28px;
        }

        /* Minecrafté£æ ¼å¡ç‰‡ */
        .glass-container {
            background-color: rgba(33, 33, 33, 0.9);
            border: 3px solid var(--mc-border);
            box-shadow: 0 6px 0 rgba(0,0,0,0.8), inset 0 1px 0 rgba(255,255,255,0.1);
            padding: 24px;
            margin-bottom: 24px;
            position: relative;
        }

        .glass-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(to bottom, rgba(255,255,255,0.1), transparent);
            pointer-events: none;
        }

        /* ä¸Šä¼ åŒºåŸŸ - MCé£æ ¼ */
        .upload-section {
            margin-bottom: 20px;
        }

        .upload-zone {
            background-color: rgba(0,0,0,0.3);
            border: 3px dashed var(--mc-bg-button);
            border-radius: 0;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }

        .upload-zone:hover, .upload-zone.dragover {
            border-color: var(--mc-green);
            background-color: rgba(59, 133, 38, 0.1);
            box-shadow: inset 0 0 30px rgba(59, 133, 38, 0.2);
        }

        .upload-zone.dragover {
            border-style: solid;
            background-color: rgba(59, 133, 38, 0.2);
        }

        .upload-icon-main {
            width: 64px;
            height: 64px;
            background-color: var(--mc-bg-button);
            border: 3px solid var(--mc-border);
            border-bottom: 6px solid var(--mc-border);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px;
            color: var(--mc-green);
            font-size: 28px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.5);
        }

        .upload-title-main {
            color: var(--mc-gray-light);
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
            text-shadow: 2px 2px 0 #000;
        }

        .upload-subtitle-main {
            color: var(--mc-text-muted);
            font-size: 13px;
        }

        .upload-hint {
            margin-top: 16px;
            padding: 8px 16px;
            background-color: rgba(59, 133, 38, 0.2);
            border: 2px solid var(--mc-green);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--mc-green);
            font-size: 12px;
            font-weight: 600;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.5);
        }

        /* æ–‡ä»¶åˆ—è¡¨ */
        .packs-list-container {
            margin-top: 20px;
        }

        .section-subheader {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            color: var(--mc-gray-light);
            font-size: 15px;
            font-weight: 600;
            text-shadow: 2px 2px 0 #000;
        }

        .pack-count {
            background-color: var(--mc-green);
            color: var(--mc-gray-light);
            padding: 4px 12px;
            border: 2px solid var(--mc-border);
            border-bottom: 4px solid var(--mc-border);
            font-size: 12px;
            font-weight: 700;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
        }

        .packs-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 100px;
        }

        .pack-item {
            background-color: var(--mc-bg-button);
            border: 3px solid var(--mc-border);
            border-bottom: 6px solid var(--mc-border);
            display: flex;
            flex-direction: column;
            cursor: move;
            transition: all 0.1s;
            position: relative;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.1);
        }

        .pack-item:hover {
            border-color: var(--mc-green);
        }

        .pack-item.dragging {
            opacity: 0.6;
            border-color: var(--mc-green);
        }

        .pack-item.drag-over {
            border-top: 4px solid var(--mc-green);
            margin-top: 8px;
        }

        .pack-item.error {
            border-color: var(--mc-red);
        }

        .pack-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
        }

        .pack-handle {
            color: var(--mc-text-muted);
            font-size: 16px;
            cursor: grab;
            padding: 8px;
            margin: -8px;
        }

        .pack-handle:active {
            cursor: grabbing;
            color: var(--mc-green);
        }

        .pack-number {
            width: 32px;
            height: 32px;
            background-color: var(--mc-green);
            border: 2px solid var(--mc-border);
            border-bottom: 4px solid var(--mc-border);
            color: var(--mc-gray-light);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
            flex-shrink: 0;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
        }

        .pack-info {
            flex: 1;
            min-width: 0;
        }

        .pack-name {
            color: var(--mc-gray-light);
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-shadow: 1px 1px 0 #000;
        }

        .pack-path {
            color: var(--mc-text-muted);
            font-size: 11px;
            margin-bottom: 4px;
        }

        .pack-meta {
            color: var(--mc-text-muted);
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pack-status {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            background-color: rgba(59, 133, 38, 0.2);
            color: var(--mc-green);
            border: 1px solid var(--mc-green);
            font-size: 11px;
            font-weight: 600;
        }

        .pack-status.error {
            background-color: rgba(139, 58, 58, 0.2);
            color: #ff6b6b;
            border-color: var(--mc-red);
        }

        .pack-actions {
            display: flex;
            gap: 8px;
        }

        .pack-btn {
            width: 32px;
            height: 32px;
            border: 2px solid var(--mc-border);
            border-bottom: 4px solid var(--mc-border);
            background-color: var(--mc-bg-panel);
            color: var(--mc-gray-light);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
        }

        .pack-btn:hover {
            background-color: var(--mc-green);
            transform: translateY(-1px);
        }

        .pack-btn:active {
            border-bottom: 2px solid var(--mc-border);
            transform: translateY(2px);
        }

        .pack-btn.delete:hover {
            background-color: var(--mc-red);
        }

        .pack-btn.expand {
            width: auto;
            padding: 0 12px;
            font-size: 12px;
            gap: 4px;
        }

        .pack-btn.expand:hover {
            background-color: var(--mc-green);
        }

        /* çš®è‚¤åˆ—è¡¨å±•å¼€åŒºåŸŸ */
        .skins-expandable {
            border-top: 2px solid var(--mc-border);
            background-color: rgba(0,0,0,0.3);
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .skins-expandable.expanded {
            max-height: 2000px;
            overflow-y: auto;
        }

        .skins-list {
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .skin-item {
            background-color: var(--mc-bg-panel);
            border: 2px solid var(--mc-border);
            border-bottom: 4px solid var(--mc-border);
            padding: 10px 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.1s;
        }

        .skin-item:hover {
            border-color: var(--mc-green);
            transform: translateX(4px);
        }

        .skin-index {
            width: 24px;
            height: 24px;
            background-color: var(--mc-bg-button);
            border: 2px solid var(--mc-border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
            color: var(--mc-text-muted);
            flex-shrink: 0;
        }

        .skin-details {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .skin-name {
            font-size: 13px;
            font-weight: 600;
            color: var(--mc-gray-light);
            text-shadow: 1px 1px 0 #000;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .skin-geometry {
            font-size: 11px;
            color: var(--mc-text-muted);
            font-family: 'Consolas', monospace;
        }

        .skin-texture {
            font-size: 11px;
            color: var(--mc-green);
        }

        .skin-animations {
            font-size: 10px;
            color: var(--mc-text-muted);
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 2px;
        }

        .anim-tag {
            background-color: rgba(59, 133, 38, 0.2);
            padding: 2px 6px;
            border: 1px solid rgba(59, 133, 38, 0.5);
            border-radius: 2px;
        }

        .skin-flags {
            display: flex;
            gap: 6px;
            margin-top: 4px;
        }

        .flag-tag {
            font-size: 10px;
            padding: 2px 6px;
            background-color: var(--mc-bg-button);
            border: 1px solid var(--mc-border);
            color: var(--mc-text-muted);
        }

        .flag-tag.active {
            background-color: rgba(59, 133, 38, 0.3);
            color: var(--mc-green);
            border-color: var(--mc-green);
        }

        .skin-delete-btn {
            width: 28px;
            height: 28px;
            border: 2px solid var(--mc-border);
            border-bottom: 4px solid var(--mc-border);
            background-color: var(--mc-bg-button);
            color: var(--mc-gray-light);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
            flex-shrink: 0;
        }

        .skin-delete-btn:hover {
            background-color: var(--mc-red);
            transform: translateY(-1px);
        }

        .skin-delete-btn:active {
            border-bottom: 2px solid var(--mc-border);
            transform: translateY(2px);
        }

        .skin-delete-btn:disabled {
            background-color: var(--mc-bg-dark);
            color: var(--mc-text-muted);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .skin-delete-btn:disabled:hover {
            background-color: var(--mc-bg-dark);
        }

        /* å¤šé€‰æ¨¡å¼ç›¸å…³æ ·å¼ */
        .skins-list-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background-color: var(--mc-bg-button);
            border: 2px solid var(--mc-border);
            border-bottom: 4px solid var(--mc-border);
            margin-bottom: 8px;
        }

        .skins-list-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--mc-text-muted);
            font-size: 12px;
            font-weight: 600;
            text-shadow: 1px 1px 0 #000;
        }

        .btn-multi-delete {
            padding: 6px 14px;
            background-color: var(--mc-red);
            border: 2px solid var(--mc-border);
            border-bottom: 4px solid var(--mc-border);
            color: var(--mc-gray-light);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.1s;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
        }

        .btn-multi-delete:hover:not(:disabled) {
            background-color: var(--mc-red-hover);
            transform: translateY(-1px);
        }

        .btn-multi-delete:active:not(:disabled) {
            border-bottom: 2px solid var(--mc-border);
            transform: translateY(2px);
        }

        .btn-multi-delete:disabled {
            background-color: var(--mc-bg-dark);
            color: var(--mc-text-muted);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .btn-toggle-multi {
            padding: 6px 14px;
            background-color: var(--mc-bg-panel);
            border: 2px solid var(--mc-border);
            border-bottom: 4px solid var(--mc-border);
            color: var(--mc-gray-light);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.1s;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
        }

        .btn-toggle-multi:hover {
            background-color: var(--mc-green);
            transform: translateY(-1px);
        }

        .btn-toggle-multi.active {
            background-color: var(--mc-green);
            border-bottom: 2px solid var(--mc-border);
            transform: translateY(2px);
        }

        .skin-item.multi-selected {
            background-color: rgba(59, 133, 38, 0.2);
            border-color: var(--mc-green);
        }

        .skin-item .skin-checkbox-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            flex-shrink: 0;
        }

        .skin-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--mc-green);
        }

        /* æŸ¥çœ‹æ¨¡å‹æŒ‰é’® */
        .skin-view-btn {
            width: 28px;
            height: 28px;
            border: 2px solid var(--mc-border);
            border-bottom: 4px solid var(--mc-border);
            background-color: var(--mc-green);
            color: var(--mc-gray-light);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
            flex-shrink: 0;
            margin-right: 8px;
        }

        .skin-view-btn:hover {
            background-color: var(--mc-green-hover);
            transform: translateY(-1px);
        }

        .skin-view-btn:active {
            border-bottom: 2px solid var(--mc-border);
            transform: translateY(2px);
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: var(--mc-text-muted);
            font-size: 14px;
            background-color: rgba(0,0,0,0.2);
            border: 3px dashed var(--mc-bg-button);
        }

        /* åˆ†æ®µæŒ‰é’®ç»„ - MCé£æ ¼ */
        .section-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
            color: var(--mc-gray-light);
            font-size: 16px;
            font-weight: 600;
            text-shadow: 2px 2px 0 #000;
        }

        .section-header i {
            color: var(--mc-green);
        }

        .preset-pills {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 16px;
        }

        .preset-pill {
            padding: 10px 20px;
            background-color: var(--mc-bg-button);
            border: 3px solid var(--mc-border);
            border-bottom: 6px solid var(--mc-border);
            font-size: 13px;
            font-weight: 600;
            color: var(--mc-gray-light);
            cursor: pointer;
            transition: all 0.1s;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.1);
            text-shadow: 1px 1px 0 #000;
        }

        .preset-pill:hover {
            background-color: #4a4a4a;
            transform: translateY(-1px);
        }

        .preset-pill.active {
            background-color: var(--mc-green);
            color: var(--mc-gray-light);
            border-bottom: 4px solid var(--mc-border);
            transform: translateY(2px);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }

        .preset-hint {
            font-size: 12px;
            color: var(--mc-text-muted);
            display: flex;
            align-items: center;
            gap: 6px;
            padding-top: 12px;
            border-top: 2px solid var(--mc-bg-button);
        }

        /* é€‰é¡¹ç½‘æ ¼ */
        .options-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            background-color: rgba(0,0,0,0.2);
            border: 3px solid var(--mc-border);
            border-bottom: 6px solid var(--mc-border);
            padding: 20px;
            margin-bottom: 20px;
        }

        .option-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background-color: var(--mc-bg-button);
            border: 2px solid var(--mc-border);
            border-bottom: 4px solid var(--mc-border);
            transition: all 0.1s;
        }

        .option-item:hover {
            transform: translateX(2px);
            border-color: var(--mc-green);
        }

        .option-label {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--mc-gray-light);
            font-size: 13px;
            font-weight: 600;
            text-shadow: 1px 1px 0 #000;
        }

        .option-label i {
            color: var(--mc-green);
            width: 20px;
            text-align: center;
        }

        /* MCé£æ ¼å¼€å…³ */
        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            cursor: pointer;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--mc-bg-dark);
            border: 2px solid var(--mc-border);
            transition: .2s;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: var(--mc-text-muted);
            border: 2px solid var(--mc-border);
            transition: .2s;
            box-shadow: 0 2px 0 rgba(0,0,0,0.5);
        }

        input:checked + .slider {
            background-color: var(--mc-green);
        }

        input:checked + .slider:before {
            transform: translateX(20px);
            background-color: var(--mc-gray-light);
        }

        /* åˆå¹¶æŒ‰é’® - MCé£æ ¼å¤§æŒ‰é’® */
        .btn-merge {
            width: 100%;
            padding: 16px;
            background-color: var(--mc-green);
            color: var(--mc-gray-light);
            border: 3px solid var(--mc-border);
            border-bottom: 6px solid var(--mc-border);
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
            box-shadow: inset 0 2px 0 rgba(255,255,255,0.1);
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-merge:hover:not(:disabled) {
            background-color: var(--mc-green-hover);
            transform: translateY(-2px);
        }

        .btn-merge:active:not(:disabled) {
            border-bottom: 3px solid var(--mc-border);
            transform: translateY(4px);
        }

        .btn-merge:disabled {
            background-color: var(--mc-bg-button);
            color: var(--mc-text-muted);
            cursor: not-allowed;
            border-bottom: 4px solid var(--mc-border);
        }

        /* è¿›åº¦æ¡ */
        .progress-container {
            background-color: rgba(0,0,0,0.3);
            border: 3px solid var(--mc-border);
            border-bottom: 6px solid var(--mc-border);
            padding: 20px;
            margin-bottom: 20px;
            display: none;
        }

        .progress-bar-bg {
            height: 20px;
            background-color: var(--mc-bg-dark);
            border: 2px solid var(--mc-border);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 12px;
            position: relative;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--mc-green);
            width: 0%;
            transition: width 0.3s;
            box-shadow: inset 0 2px 0 rgba(255,255,255,0.2);
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 10px,
                rgba(0,0,0,0.1) 10px,
                rgba(0,0,0,0.1) 20px
            );
            animation: slide 1s linear infinite;
        }

        @keyframes slide {
            0% { transform: translateX(-20px); }
            100% { transform: translateX(0); }
        }

        .progress-text {
            color: var(--mc-gray-light);
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            text-shadow: 1px 1px 0 #000;
        }

        .progress-text i {
            animation: spin 1s linear infinite;
            color: var(--mc-green);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ç»“æœåŒºåŸŸ */
        .result-container {
            background-color: rgba(59, 133, 38, 0.1);
            border: 3px solid var(--mc-green);
            border-bottom: 6px solid var(--mc-border);
            padding: 24px;
            text-align: center;
            display: none;
            margin-bottom: 20px;
        }

        .result-icon {
            width: 56px;
            height: 56px;
            background-color: var(--mc-green);
            border: 3px solid var(--mc-border);
            border-bottom: 6px solid var(--mc-border);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: var(--mc-gray-light);
            font-size: 24px;
            margin-bottom: 12px;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.3);
        }

        .result-title {
            color: var(--mc-gray-light);
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 16px;
            text-shadow: 2px 2px 0 #000;
        }

        .btn-download {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 14px 28px;
            background-color: var(--mc-green);
            color: var(--mc-gray-light);
            text-decoration: none;
            border: 3px solid var(--mc-border);
            border-bottom: 6px solid var(--mc-border);
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.1s;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
        }

        .btn-download:hover {
            background-color: var(--mc-green-hover);
            transform: translateY(-2px);
        }

        .btn-download:active {
            border-bottom: 3px solid var(--mc-border);
            transform: translateY(4px);
        }

        /* æ—¥å¿—åŒºåŸŸ */
        .log-container {
            background-color: rgba(0,0,0,0.5);
            border: 3px solid var(--mc-border);
            border-bottom: 6px solid var(--mc-border);
            padding: 16px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .log-header {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--mc-green);
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--mc-bg-button);
            text-shadow: 1px 1px 0 rgba(0,0,0,0.5);
            position: sticky;
            top: 0;
            background-color: rgba(0,0,0,0.8);
            z-index: 10;
        }

        .log-content {
            font-size: 12px;
            line-height: 1.6;
            color: var(--mc-gray-light);
        }

        .log-content div {
            padding: 2px 0;
            border-left: 2px solid var(--mc-green);
            padding-left: 8px;
            margin-bottom: 4px;
        }

        .log-content div::before {
            content: '>';
            color: var(--mc-green);
            margin-right: 6px;
            font-weight: bold;
        }

        /* æ¨¡å‹é¢„è§ˆå†…è”åŒºåŸŸ */
        .model-viewer-inline {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            border-top: 2px solid var(--mc-border);
            background-color: rgba(0,0,0,0.3);
        }

        .model-viewer-inline.expanded {
            max-height: 500px;
            overflow: visible;
        }

        .model-viewer-inline-content {
            padding: 16px;
        }

        .model-viewer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            color: var(--mc-gray-light);
            font-size: 14px;
            font-weight: 600;
            text-shadow: 2px 2px 0 #000;
        }

        .model-viewer-header i {
            color: var(--mc-green);
        }

        .model-viewer-canvas {
            height: 300px;
            background: #1a1a2e;
            position: relative;
            overflow: hidden;
            border: 2px solid var(--mc-border);
            border-bottom: 4px solid var(--mc-border);
        }

        /* æ»šåŠ¨æ¡ - MCé£æ ¼ */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: var(--mc-bg-dark);
            border: 2px solid var(--mc-border);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--mc-bg-button);
            border: 2px solid var(--mc-border);
            border-bottom: 4px solid var(--mc-border);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--mc-green);
        }

        /* å“åº”å¼ */
        @media (max-width: 1024px) {
            .options-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                display: none;
            }
            .main-content {
                margin-left: 0;
                padding: 20px;
            }
            .options-grid {
                grid-template-columns: 1fr;
            }
            .upload-zone {
                padding: 30px 20px;
            }
            .model-viewer-canvas {
                height: 250px;
            }
        }
    </style>
    <script src="./js/jszip.min.js"></script>
            <script src="./js/FileSaver.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script><base target="_blank">
</head>

<body>
    <aside class="sidebar">
        <div class="logo">
            <i class="fas fa-cube"></i>
        </div>
        <div class="version">v3.0</div>
    </aside>

    <main class="main-content">
        <div class="page-header">
            <h1 class="page-title">
                <i class="fas fa-layer-group"></i>
                Minecraft 4Dçš®è‚¤åŒ…åˆå¹¶å·¥å…·
            </h1>
        </div>

        <!-- ä¸Šä¼ åŒºåŸŸ -->
        <div class="glass-container">
            <div class="upload-section">
                <div class="upload-zone" id="uploadZone">
                    <div class="upload-icon-main">
                        <i class="fas fa-cloud-upload-alt"></i>
                    </div>
                    <div class="upload-title-main">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ çš®è‚¤åŒ…</div>
                    <div class="upload-subtitle-main">æ”¯æŒå¤šé€‰ZIPæ–‡ä»¶ï¼Œå¯å¤šæ¬¡æ·»åŠ </div>
                    <div class="upload-hint">
                        <i class="fas fa-lightbulb"></i>
                        <span>è‡ªåŠ¨è¯†åˆ«å¤šçº§æ–‡ä»¶å¤¹ç»“æ„</span>
                    </div>
                    <input type="file" id="fileInput" style="display: none;" accept=".zip" multiple>
                </div>
            </div>

            <!-- å·²ä¸Šä¼ åˆ—è¡¨ -->
            <div class="packs-list-container" id="packsListContainer" style="display: none;">
                <div class="section-subheader">
                    <span>å·²ä¸Šä¼ çš„çš®è‚¤åŒ… <span style="color: #888; font-size: 13px; font-weight: normal;">ï¼ˆæ‹–æ‹½å¯è°ƒæ•´åˆå¹¶é¡ºåºï¼Œç‚¹å‡»å±•å¼€æŸ¥çœ‹çš®è‚¤åˆ—è¡¨ï¼‰</span></span>
                    <span class="pack-count" id="packCount">0 ä¸ª</span>
                </div>
                <div class="packs-list" id="packsList"></div>
            </div>

            <div class="empty-state" id="emptyState">
                <i class="fas fa-box-open" style="font-size: 32px; margin-bottom: 8px; display: block; opacity: 0.5;"></i>
                <div>æš‚æ— çš®è‚¤åŒ…ï¼Œè¯·ä¸Šä¼ æ–‡ä»¶</div>
            </div>
        </div>

        <!-- é¢„è®¾é…ç½® -->
        <div class="glass-container">
            <div class="section-header">
                <i class="fas fa-magic"></i>
                <span>é…ç½®é¢„è®¾</span>
            </div>
            <div class="preset-pills">
                <button class="preset-pill" data-preset="1">çš®è‚¤/æ¨¡å‹å…¼å®¹</button>
                <button class="preset-pill" data-preset="2">å¯åŠ¨å™¨é€‚é…</button>
                <button class="preset-pill" data-preset="3">çš®è‚¤åç®€åŒ–</button>
                <button class="preset-pill" data-preset="4">å°ç™½å…¨èƒ½ç‰ˆ</button>
            </div>
            <div class="preset-hint">
                <i class="fas fa-info-circle"></i>
                <span>ç‚¹å‡»é¢„è®¾å¯å¿«é€Ÿé…ç½®å¸¸ç”¨é€‰é¡¹ç»„åˆï¼Œå¯ä¸æ‰‹åŠ¨è®¾ç½®å åŠ ä½¿ç”¨</span>
            </div>
        </div>

        <!-- é€‰é¡¹åŒºåŸŸ -->
        <div class="glass-container">
            <div class="section-header" style="margin-top: -8px;">
                <i class="fas fa-sliders-h"></i>
                <span>é«˜çº§è®¾ç½®</span>
            </div>
            <div class="options-grid">
                <div class="option-item">
                    <div class="option-label">
                        <i class="fas fa-clone"></i>
                        <span>é‡åæ¨¡å‹å…¼å®¹</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="compatibleRenameModel">
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="option-item">
                    <div class="option-label">
                        <i class="fas fa-font"></i>
                        <span>å‘½åç®€åŒ–</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="simplifyNaming">
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="option-item">
                    <div class="option-label">
                        <i class="fas fa-fingerprint"></i>
                        <span>UUIDæ›¿æ¢</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="replaceUuid">
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="option-item">
                    <div class="option-label">
                        <i class="fas fa-tshirt"></i>
                        <span>éšè—ç›”ç”²</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="addHideArmor">
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="option-item">
                    <div class="option-label">
                        <i class="fas fa-globe"></i>
                        <span>å›½å¤–ä½œè€…çš®è‚¤åŒ…é€‚é…</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="fixComments">
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="option-item">
                    <div class="option-label">
                        <i class="fas fa-box-open"></i>
                        <span>è¾“å‡ºä¸ºmcpack</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="outputMcpack">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
        </div>

        <button class="btn-merge" id="mergeBtn" disabled>
            <i class="fas fa-code-branch"></i>
            <span id="mergeBtnText">å¼€å§‹åˆå¹¶çš®è‚¤åŒ…</span>
        </button>

        <div class="progress-container" id="progressContainer">
            <div class="progress-bar-bg">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">
                <i class="fas fa-spinner"></i>
                å‡†å¤‡åˆå¹¶...
            </div>
        </div>

        <div class="result-container" id="resultContainer">
            <div class="result-icon">
                <i class="fas fa-check"></i>
            </div>
            <div class="result-title">åˆå¹¶æˆåŠŸï¼</div>
            <button class="btn-download" id="downloadBtn">
                <i class="fas fa-download"></i>
                ä¸‹è½½åˆå¹¶åçš„çš®è‚¤åŒ…
            </button>
        </div>

        <div class="glass-container" style="padding: 0; overflow: hidden;">
            <div class="log-container" id="log">
                <div class="log-header">
                    <i class="fas fa-terminal"></i>
                    <span>å¤„ç†æ—¥å¿—</span>
                </div>
                <div class="log-content" id="logContent"></div>
            </div>
        </div>
    </main>

    

    <script>
        (() => {
            'use strict';

            // å¸¸é‡å®šä¹‰
            const CORE_FILES = ['manifest.json', 'geometry.json', 'skins.json'];
            const PRESET_CONFIGS = {
                1: { name: "åŒæ¨¡å‹å…¼å®¹", settings: { compatibleRenameModel: true, fixComments: true } },
                2: { name: "å¯åŠ¨å™¨é€‚é…", settings: { replaceUuid: true, outputMcpack: true } },
                3: { name: "ç®€åŒ–åˆå¹¶", settings: { simplifyNaming: true, addHideArmor: true } },
                4: { name: "å…¨èƒ½ç‰ˆ", settings: { compatibleRenameModel: true, simplifyNaming: true, replaceUuid: true, addHideArmor: true, fixComments: true } }
            };

            // çŠ¶æ€ç®¡ç†
            const state = {
                skinPacks: [],
                mergeInProgress: false,
                dragStartIndex: null,
                modelTextureRelations: new Map()
            };

            // DOM å…ƒç´ ç¼“å­˜
            const elements = {
                uploadZone: document.getElementById('uploadZone'),
                fileInput: document.getElementById('fileInput'),
                packsListContainer: document.getElementById('packsListContainer'),
                packsList: document.getElementById('packsList'),
                emptyState: document.getElementById('emptyState'),
                packCount: document.getElementById('packCount'),
                mergeBtn: document.getElementById('mergeBtn'),
                mergeBtnText: document.getElementById('mergeBtnText'),
                progressFill: document.getElementById('progressFill'),
                progressText: document.getElementById('progressText'),
                progressContainer: document.getElementById('progressContainer'),
                resultContainer: document.getElementById('resultContainer'),
                downloadBtn: document.getElementById('downloadBtn'),
                logContent: document.getElementById('logContent'),
                log: document.getElementById('log'),
                fixComments: document.getElementById('fixComments'),
                compatibleRenameModel: document.getElementById('compatibleRenameModel'),
                simplifyNaming: document.getElementById('simplifyNaming'),
                replaceUuid: document.getElementById('replaceUuid'),
                addHideArmor: document.getElementById('addHideArmor'),
                outputMcpack: document.getElementById('outputMcpack')
            };

            // å·¥å…·å‡½æ•°
            const utils = {
                generateUUID: () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                    const r = Math.random() * 16 | 0;
                    return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
                }),

                getSafeFileName: name => name.replace(/[\\/:*?"<>|]/g, '_').trim(),

                removeComments: jsonStr => jsonStr.replace(/(".*?")|(\/\/.*)/g, (match, str) => str || '').replace(/^\s*[\r\n]/gm, '').trim(),

                fixJsonSyntax: jsonStr => jsonStr
                    .replace(/,\s*}/g, '}')
                    .replace(/,\s*]/g, ']')
                    .replace(/(?<!\\)'/g, '"')
                    .replace(/([{,]\s*)(\w+)(\s*:)/g, '$1"$2"$3'),

                removeCommentsAndFixGeometry: jsonStr => {
                    let cleaned = utils.removeComments(jsonStr);
                    return cleaned.replace(/,\s*"geometry\.null"\s*:\s*\{\s*\}/g, '').replace(/"geometry\.null"\s*:\s*\{\s*\},?/g, '');
                },

                countSkins: content => {
                    try {
                        const data = JSON.parse(content);
                        return data.skins?.length || 0;
                    } catch {
                        return 0;
                    }
                },

                updateProgress: (percent, text) => {
                    elements.progressFill.style.width = `${percent}%`;
                    elements.progressText.innerHTML = `<i class="fas fa-spinner"></i> ${text}`;
                }
            };

            // æ—¥å¿—ç³»ç»Ÿ
            const logger = {
                add: text => {
                    const div = document.createElement('div');
                    div.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
                    elements.logContent.appendChild(div);
                    elements.log.scrollTop = elements.log.scrollHeight;
                },
                clear: () => {
                    elements.logContent.innerHTML = '';
                }
            };

            // çš®è‚¤åˆ é™¤å¤„ç†å™¨ - æ™ºèƒ½å¤„ç†JSONé€—å·
            const skinDeleter = {
                deleteSkin(packId, skinIndex) {
                    const pack = state.skinPacks.find(p => p.id === packId);
                    if (!pack || !pack.files['skins.json']) return false;

                    const skinsContent = pack.files['skins.json']._content;
                    const skinsData = JSON.parse(skinsContent);
                    
                    if (skinsData.skins.length <= 1) {
                        logger.add(`âš ï¸ æ— æ³•åˆ é™¤ï¼š${pack.fileName} è‡³å°‘éœ€è¦ä¿ç•™1ä¸ªçš®è‚¤`);
                        return false;
                    }

                    if (skinIndex < 0 || skinIndex >= skinsData.skins.length) return false;

                    // è·å–è¦åˆ é™¤çš„çš®è‚¤ä¿¡æ¯
                    const deletedSkin = skinsData.skins[skinIndex];
                    const newSkins = skinsData.skins.filter((_, idx) => idx !== skinIndex);
                    
                    // é‡å»ºJSONå­—ç¬¦ä¸²ï¼Œæ™ºèƒ½å¤„ç†é€—å·
                    const newJsonString = this.rebuildSkinsJson(skinsContent, skinsData.skins, skinIndex);
                    
                    // æ›´æ–°æ–‡ä»¶å†…å®¹
                    pack.files['skins.json']._content = newJsonString;
                    pack.skinCount = newSkins.length;
                    
                    // å¦‚æœè¯¥çš®è‚¤æœ‰ä¸“å±è´´å›¾ä¸”ä¸å†è¢«ä½¿ç”¨ï¼Œæ ‡è®°ä¸ºå¾…åˆ é™¤
                    this.cleanupUnusedTexture(pack, deletedSkin.texture, newSkins);

                    logger.add(`ğŸ—‘ï¸ å·²åˆ é™¤çš®è‚¤: ${deletedSkin.localization_name || `skin_${skinIndex}`} (${pack.fileName})`);
                    return true;
                },

                rebuildSkinsJson(originalContent, skins, deleteIndex) {
                    // è§£æåŸå§‹JSONå­—ç¬¦ä¸²ä»¥å‡†ç¡®å®šä½
                    const data = JSON.parse(originalContent);
                    const skinArray = data.skins;
                    
                    // æ„å»ºæ–°çš„skinsæ•°ç»„
                    const newSkins = skinArray.filter((_, idx) => idx !== deleteIndex);
                    
                    // é‡å»ºæ•´ä¸ªJSONå¯¹è±¡
                    const newData = { ...data, skins: newSkins };
                    
                    // æ ¼å¼åŒ–è¾“å‡ºï¼Œç¡®ä¿æ ¼å¼ä¸¥è°¨
                    return JSON.stringify(newData, null, 2);
                },

                cleanupUnusedTexture(pack, textureName, remainingSkins) {
                    const textureLower = textureName.toLowerCase();
                    const stillInUse = remainingSkins.some(s => s.texture.toLowerCase() === textureLower);
                    
                    if (!stillInUse && pack.files[textureLower]) {
                        // æ ‡è®°è´´å›¾ä¸ºæœªä½¿ç”¨ï¼ˆå®é™…åˆ é™¤åœ¨åˆå¹¶æ—¶å¤„ç†ï¼‰
                        pack.files[textureLower]._unused = true;
                        logger.add(`   ğŸ“ è´´å›¾ ${textureName} ä¸å†è¢«ä½¿ç”¨`);
                    }
                }
            };

            // æ–‡ä»¶å¤„ç†æ¨¡å—
            const fileHandler = {
                async extractZip(zipFile, pack) {
                    const zip = await JSZip.loadAsync(zipFile);
                    const allFiles = Object.entries(zip.files)
                        .filter(([, file]) => !file.dir)
                        .map(([path, file]) => ({ path, file, lowerPath: path.toLowerCase() }));

                    const coreFilesLocation = this.detectCoreFilesLocation(allFiles);
                    pack.rootPath = coreFilesLocation;

                    for (const { path, file } of allFiles) {
                        const textContent = await file.async('text');
                        const mappedFileName = this.mapFileName(path, coreFilesLocation);

                        pack.files[mappedFileName] = {
                            blob: await file.async('blob'),
                            name: mappedFileName,
                            originalPath: path,
                            _content: textContent,
                            get content() { return Promise.resolve(this._content); }
                        };
                    }
                },

                detectCoreFilesLocation(files) {
                    const findFile = name => files.find(f => f.lowerPath === name || f.lowerPath.endsWith(`/${name}`));
                    
                    const manifest = findFile('manifest.json');
                    const geometry = findFile('geometry.json');
                    const skins = findFile('skins.json');

                    if (manifest && geometry && skins) {
                        const idx = manifest.path.lastIndexOf('/');
                        return idx > 0 ? manifest.path.substring(0, idx + 1) : '';
                    }

                    const folderScores = {};
                    files.forEach(({ path, lowerPath }) => {
                        if (['manifest.json', 'geometry.json', 'skins.json'].some(f => lowerPath.endsWith(f))) {
                            const folder = path.substring(0, path.lastIndexOf('/') + 1);
                            folderScores[folder] = (folderScores[folder] || 0) + 1;
                        }
                    });

                    const bestFolder = Object.entries(folderScores).sort((a, b) => b[1] - a[1])[0];
                    return bestFolder && bestFolder[1] >= 3 ? bestFolder[0] : '';
                },

                mapFileName(path, corePath) {
                    const fileName = path.split('/').pop().toLowerCase();
                    const coreFiles = ['manifest.json', 'geometry.json', 'skins.json'];
                    
                    if (path.startsWith(corePath)) {
                        return coreFiles.includes(fileName) ? fileName : path.substring(corePath.length).toLowerCase();
                    }
                    return path.toLowerCase();
                },

                async loadCore(files, packName) {
                    const coreData = {};
                    
                    for (const fileName of CORE_FILES) {
                        const file = files[fileName];
                        if (!file) throw new Error(`${packName} ç¼ºå°‘ ${fileName}`);
                        
                        let content = file._content;
                        if (elements.fixComments.checked) {
                            logger.add(`ğŸŒ å›½å¤–ä½œè€…é€‚é…ï¼šæ¸…ç† ${packName} çš„ ${fileName}`);
                            content = utils.removeCommentsAndFixGeometry(content);
                        }
                        
                        try {
                            coreData[fileName] = JSON.parse(content);
                        } catch {
                            try {
                                coreData[fileName] = JSON.parse(utils.fixJsonSyntax(content));
                                logger.add(`âœ… ${fileName} è‡ªåŠ¨ä¿®å¤æˆåŠŸ`);
                            } catch (e) {
                                throw new Error(`${fileName} JSONè§£æå¤±è´¥ä¸”æ— æ³•è‡ªåŠ¨ä¿®å¤ï¼š${e.message}`);
                            }
                        }

                        if (fileName === 'geometry.json' && coreData[fileName]?.['geometry.null']) {
                            delete coreData[fileName]['geometry.null'];
                            logger.add(`ğŸ—‘ï¸ å·²ç§»é™¤ geometry.null ç©ºå®šä¹‰ï¼ˆå›½å¤–ä½œè€…åŒ…é€‚é…ï¼‰`);
                        }
                    }
                    
                    return coreData;
                }
            };

            // æ¨¡å‹-è´´å›¾å…³ç³»æ‰«æ
            const relationScanner = {
                scan(coreData, packId) {
                    const relations = {
                        modelToTextures: new Map(),
                        textureToModels: new Map(),
                        skinToModel: new Map(),
                        skinToTexture: new Map()
                    };

                    const skins = coreData['skins.json']?.skins;
                    if (!skins) return relations;

                    skins.forEach((skin, idx) => {
                        const skinName = skin.localization_name || `skin_${idx}`;
                        const modelName = skin.geometry;
                        const textureName = skin.texture.toLowerCase();

                        relations.skinToModel.set(skinName, modelName);
                        relations.skinToTexture.set(skinName, textureName);

                        this.addToMap(relations.modelToTextures, modelName, textureName);
                        this.addToMap(relations.textureToModels, textureName, modelName);
                    });

                    // è½¬æ¢ä¸ºæ•°ç»„
                    for (const map of [relations.modelToTextures, relations.textureToModels]) {
                        for (const [key, val] of map) map.set(key, Array.from(val));
                    }

                    state.modelTextureRelations.set(packId, relations);
                    this.logRelations(relations);
                    return relations;
                },

                addToMap(map, key, value) {
                    if (!map.has(key)) map.set(key, new Set());
                    map.get(key).add(value);
                },

                logRelations(r) {
                    logger.add(`ğŸ” æ‰«æçš®è‚¤åŒ…å…³è”å…³ç³»ï¼š`);
                    logger.add(`   - æ¨¡å‹æ•°ï¼š${r.modelToTextures.size} | è´´å›¾æ•°ï¼š${r.textureToModels.size} | çš®è‚¤æ•°ï¼š${r.skinToModel.size}`);

                    for (const [model, textures] of r.modelToTextures) {
                        if (textures.length > 1) logger.add(`   âš ï¸ æ¨¡å‹ã€${model}ã€‘å…³è”å¤šä¸ªè´´å›¾ï¼š${textures.join(', ')}`);
                    }
                    for (const [texture, models] of r.textureToModels) {
                        if (models.length > 1) logger.add(`   âš ï¸ è´´å›¾ã€${texture}ã€‘å…³è”å¤šä¸ªæ¨¡å‹ï¼š${models.join(', ')}`);
                    }
                }
            };

            // å‘½åå¤„ç†å™¨
            const namingHandler = {
                compatibleSimplify(core, packId, startIndex) {
                    const relations = state.modelTextureRelations.get(packId);
                    if (!relations) return { skins: [], geoRenameMap: new Map(), textureMap: new Map() };

                    const modelHasMultiTextures = new Map();
                    const textureHasMultiModels = new Map();
                    const modelTextureSuffixMap = new Map();

                    // åˆ†æå¤šé‡å…³è”
                    for (const [model, textures] of relations.modelToTextures) {
                        if (textures.length > 1) {
                            modelHasMultiTextures.set(model, textures);
                            modelTextureSuffixMap.set(model, new Map(textures.map((t, i) => [t, i === 0 ? '' : `_${i + 1}`])));
                        }
                    }
                    for (const [texture, models] of relations.textureToModels) {
                        if (models.length > 1) textureHasMultiModels.set(texture, models);
                    }

                    const modelNewNameMap = new Map();
                    const textureNewNameMap = new Map();
                    let baseIndex = startIndex;

                    // å¤„ç†å•ä¸€å…³è”
                    for (const [model] of relations.modelToTextures) {
                        if (!modelHasMultiTextures.has(model) && !this.hasMultiModels(textureHasMultiModels, model)) {
                            if (!modelNewNameMap.has(model)) {
                                const newName = `geometry.skin${baseIndex}`;
                                modelNewNameMap.set(model, newName);
                                
                                const textures = relations.modelToTextures.get(model);
                                if (textures.length === 1) {
                                    textureNewNameMap.set(textures[0], `skin${baseIndex}.png`);
                                }
                                baseIndex++;
                            }
                        }
                    }

                    // å¤„ç†å¤šè´´å›¾æ¨¡å‹
                    for (const [model, textures] of modelHasMultiTextures) {
                        if (!modelNewNameMap.has(model)) {
                            const newName = `geometry.skin${baseIndex}`;
                            modelNewNameMap.set(model, newName);
                            
                            textures.forEach((texture, idx) => {
                                if (!textureNewNameMap.has(texture)) {
                                    const suffix = idx === 0 ? '' : `_${idx + 1}`;
                                    textureNewNameMap.set(texture, `skin${baseIndex}${suffix}.png`);
                                }
                            });
                            baseIndex++;
                        }
                    }

                    // å¤„ç†å¤šæ¨¡å‹è´´å›¾
                    for (const [texture, models] of textureHasMultiModels) {
                        if (!textureNewNameMap.has(texture)) {
                            textureNewNameMap.set(texture, `skin${baseIndex}.png`);
                        }
                        const baseName = textureNewNameMap.get(texture).replace('.png', '');

                        models.forEach((model, idx) => {
                            if (!modelNewNameMap.has(model)) {
                                const suffix = idx === 0 ? '' : `_${idx + 1}`;
                                modelNewNameMap.set(model, `geometry.${baseName}${suffix}`);
                            }
                        });
                        baseIndex++;
                    }

                    return this.buildResult(core, relations, modelNewNameMap, textureNewNameMap, modelTextureSuffixMap);
                },

                hasMultiModels(textureHasMultiModels, model) {
                    return Array.from(textureHasMultiModels.values()).some(models => models.includes(model));
                },

                buildResult(core, relations, modelMap, textureMap, suffixMap) {
                    const modifiedSkins = [];
                    const geoRenameMap = new Map();
                    const textureRenameMap = new Map();

                    modelMap.forEach((newName, oldName) => geoRenameMap.set(oldName, newName));
                    textureMap.forEach((newName, oldName) => textureRenameMap.set(oldName, newName));

                    core['skins.json'].skins.forEach((skin, idx) => {
                        const skinName = skin.localization_name || `skin_${idx}`;
                        const oldModel = skin.geometry;
                        const oldTexture = relations.skinToTexture.get(skinName);

                        const newModel = modelMap.get(oldModel) || oldModel;
                        const newTexture = textureMap.get(oldTexture) || oldTexture;
                        
                        let newSkinName = newModel.replace('geometry.', '');
                        if (suffixMap.has(oldModel) && suffixMap.get(oldModel).has(oldTexture)) {
                            newSkinName += suffixMap.get(oldModel).get(oldTexture);
                        }

                        modifiedSkins.push({ ...skin, localization_name: newSkinName, geometry: newModel, texture: newTexture });
                        logger.add(`ğŸ”„ å…¼å®¹é‡å‘½åï¼šçš®è‚¤ã€${skinName}ã€‘â†’ã€${newSkinName}ã€‘`);
                    });

                    return { modifiedSkins, geoRenameMap, textureMap: textureRenameMap };
                },

                simplifySingle(core, packId, startIndex) {
                    const modifiedSkins = [];
                    const geoRenameMap = new Map();
                    const textureMap = new Map();

                    core['skins.json']?.skins?.forEach((skin, idx) => {
                        const baseName = `skin${startIndex + idx}`;
                        const newGeo = `geometry.${baseName}`;
                        const newTex = `${baseName}.png`;

                        geoRenameMap.set(skin.geometry, newGeo);
                        textureMap.set(skin.texture.toLowerCase(), newTex);

                        modifiedSkins.push({ ...skin, localization_name: baseName, geometry: newGeo, texture: newTex });
                        logger.add(`ğŸ”„ ç®€åŒ–å‘½åï¼š${skin.localization_name} â†’ ${baseName}`);
                    });

                    return { modifiedSkins, geoRenameMap, textureMap };
                },

                modifyDuplicate(core, existingSkins, packPrefix) {
                    const existingNames = new Set(existingSkins.map(s => s.localization_name));
                    const existingGeo = new Set(existingSkins.map(s => s.geometry));
                    
                    const modifiedSkins = [];
                    const geoRenameMap = new Map();
                    const textureMap = new Map();

                    core['skins.json']?.skins?.forEach(skin => {
                        let newName = skin.localization_name;
                        let newGeo = skin.geometry;
                        let newTex = skin.texture.toLowerCase();

                        if (existingNames.has(newName)) newName += `_${packPrefix}`;
                        if (existingGeo.has(newGeo)) newGeo += `_${packPrefix}`;

                        existingNames.add(newName);
                        existingGeo.add(newGeo);

                        geoRenameMap.set(skin.geometry, newGeo);
                        textureMap.set(skin.texture.toLowerCase(), newTex);
                        modifiedSkins.push({ ...skin, localization_name: newName, geometry: newGeo, texture: newTex });
                    });

                    return { modifiedSkins, geoRenameMap, textureMap };
                }
            };

            // ========== æ¨¡å‹é¢„è§ˆåŠŸèƒ½ ==========
            window.ModelViewer = {
                scene: null,
                camera: null,
                renderer: null,
                currentMesh: null,
                currentTexture: null,
                isOpen: false,
                
                // ä»pack.filesä¸­è§£ægeometryæ•°æ®
                parseGeometry(data) {
                    const result = {};

                    // å¤„ç†æ ‡å‡†æ ¼å¼ï¼šminecraft:geometry æ•°ç»„
                    if (data['minecraft:geometry'] && Array.isArray(data['minecraft:geometry'])) {
                        data['minecraft:geometry'].forEach(item => {
                            if (item.description && item.description.identifier) {
                                result[item.description.identifier] = item;
                            } else {
                                Object.entries(item).forEach(([key, value]) => {
                                    if (key.startsWith('geometry.')) {
                                        result[key] = value;
                                    }
                                });
                            }
                        });
                    }

                    // å¤„ç†ç›´æ¥ä½¿ç”¨ geometry.xxx æ ¼å¼çš„æ•°æ®ï¼ˆå¦‚ geometry.unknownï¼‰
                    Object.entries(data).forEach(([key, value]) => {
                        if (key.startsWith('geometry.') && !result[key]) {
                            result[key] = value;
                        }
                    });

                    return result;
                },

                // ä¿®å¤JSONè¯­æ³•
                fixJsonSyntax(jsonText) {
                    let fixed = jsonText;
                    fixed = fixed.replace(/\/\*[\s\S]*?\*\//g, '');
                    fixed = fixed.replace(/\/\/.*$/gm, '');
                    fixed = fixed.replace(/,\s*([}\]])/g, '$1');
                    fixed = fixed.replace(/^\s*\n/gm, '');
                    return fixed;
                },

                // ç”Ÿæˆç«‹æ–¹ä½“å‡ ä½•ä½“ï¼ˆçº¯å‡€åæ ‡ç‰ˆï¼Œæ— Pivotå˜æ¢ï¼‰
                generateCubeGeometry(cube, texW, texH) {
                    const [ox, oy, oz] = cube.origin || [0, 0, 0];
                    const [sx, sy, sz] = cube.size || [1, 1, 1];
                    const [uvx, uvy] = cube.uv || [0, 0];
                    const inflate = cube.inflate || 0;

                    const inf = inflate;
                    const verts = [
                        [ox - inf, oy - inf, oz + sz + inf],
                        [ox + sx + inf, oy - inf, oz + sz + inf],
                        [ox + sx + inf, oy + sy + inf, oz + sz + inf],
                        [ox - inf, oy + sy + inf, oz + sz + inf],
                        [ox - inf, oy - inf, oz - inf],
                        [ox + sx + inf, oy - inf, oz - inf],
                        [ox + sx + inf, oy + sy + inf, oz - inf],
                        [ox - inf, oy + sy + inf, oz - inf]
                    ];

                    const faces = [
                        { verts: [5, 1, 2, 6], u: uvx + sz + sx, v: uvy + sz, w: sz, h: sy },
                        { verts: [0, 4, 7, 3], u: uvx, v: uvy + sz, w: sz, h: sy },
                        { verts: [4, 5, 6, 7], u: uvx + sz, v: uvy, w: sx, h: sz },
                        { verts: [1, 0, 3, 2], u: uvx + sz + sx, v: uvy, w: sx, h: sz },
                        { verts: [3, 7, 6, 2], u: uvx + sz, v: uvy + sz, w: sx, h: sy },
                        { verts: [4, 0, 1, 5], u: uvx + sz + sx + sz, v: uvy + sz, w: sx, h: sy }
                    ];

                    const positions = [];
                    const normals = [];
                    const uvs = [];
                    const indices = [];
                    let idx = 0;

                    const faceNormals = [
                        [1, 0, 0], [-1, 0, 0], [0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0]
                    ];

                    faces.forEach((face, fIdx) => {
                        const triIndices = [0, 1, 2, 0, 2, 3];
                        const u1 = face.u;
                        const v1 = face.v;
                        const u2 = face.u + face.w;
                        const v2 = face.v + face.h;
                        const cornerUVs = [[u1, v2], [u2, v2], [u2, v1], [u1, v1]];

                        triIndices.forEach((vi) => {
                            const vIdx = face.verts[vi];
                            const v = verts[vIdx];
                            positions.push(v[0], v[1], -v[2]);
                            const n = faceNormals[fIdx];
                            normals.push(n[0], n[1], -n[2]);
                            const uv = cornerUVs[vi];
                            uvs.push(uv[0] / texW, 1.0 - (uv[1] / texH));
                            indices.push(idx++);
                        });
                    });

                    return { positions, normals, uvs, indices };
                },

                // æ„å»ºç½‘æ ¼
                buildMesh(geoData, geoName, texture) {
                    const geo = geoData[geoName];
                    if (!geo || !geo.bones) return null;

                    const allPositions = [];
                    const allNormals = [];
                    const allUVs = [];
                    const allIndices = [];
                    let globalIndex = 0;

                    let texW = 64, texH = 64;
                    if (texture && texture.image) {
                        texW = texture.image.width;
                        texH = texture.image.height;
                    } else {
                        texW = geo.texturewidth || 64;
                        texH = geo.textureheight || 64;
                    }

                    geo.bones.forEach((bone) => {
                        if (bone.cubes) {
                            bone.cubes.forEach((cube) => {
                                const data = this.generateCubeGeometry(cube, texW, texH);
                                allPositions.push(...data.positions);
                                allNormals.push(...data.normals);
                                allUVs.push(...data.uvs);
                                for (let idx of data.indices) {
                                    allIndices.push(idx + globalIndex);
                                }
                                globalIndex += (data.positions.length / 3);
                            });
                        }

                        if (bone.poly_mesh) {
                            const polyMesh = bone.poly_mesh;
                            const verts = polyMesh.positions || [];
                            const norms = polyMesh.normals || [];
                            const uvData = polyMesh.uvs || [];
                            const polys = polyMesh.polys || [];
                            const normalized = polyMesh.normalized_uvs !== false;

                            if (verts.length > 0 && polys.length > 0) {
                                polys.forEach((poly) => {
                                    if (!Array.isArray(poly) || poly.length < 3) return;
                                    for (let i = 1; i < poly.length - 1; i++) {
                                        const tri = [poly[0], poly[i], poly[i + 1]];
                                        tri.forEach((corner) => {
                                            const vIdx = corner[0];
                                            const nIdx = corner[1] !== undefined ? corner[1] : 0;
                                            const uvIdx = corner[2] !== undefined ? corner[2] : 0;
                                            const v = verts[vIdx] || [0, 0, 0];
                                            allPositions.push(v[0], v[1], -v[2]);
                                            const n = norms[nIdx] || [0, 1, 0];
                                            allNormals.push(n[0], n[1], -n[2]);
                                            const uv = uvData[uvIdx] || [0, 0];
                                            let u = uv[0], v_uv = uv[1];
                                            if (normalized) { u *= texW; v_uv *= texH; }
                                            allUVs.push(u / texW, 1.0 - (v_uv / texH));
                                            allIndices.push(globalIndex++);
                                        });
                                    }
                                });
                            }
                        }
                    });

                    if (allPositions.length === 0) return null;

                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(allPositions, 3));
                    geometry.setAttribute('normal', new THREE.Float32BufferAttribute(allNormals, 3));
                    geometry.setAttribute('uv', new THREE.Float32BufferAttribute(allUVs, 2));
                    geometry.setIndex(allIndices);

                    geometry.computeBoundingBox();
                    const box = geometry.boundingBox;
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    const posAttr = geometry.attributes.position;
                    for (let i = 0; i < posAttr.count; i++) {
                        posAttr.setXYZ(
                            i,
                            posAttr.getX(i) - center.x,
                            posAttr.getY(i) - center.y + (size.y / 2),
                            posAttr.getZ(i) - center.z
                        );
                    }
                    posAttr.needsUpdate = true;

                    return geometry;
                },

                // åˆå§‹åŒ–Three.jsåœºæ™¯
                initScene(container) {
                    this.scene = new THREE.Scene();
                    this.scene.background = new THREE.Color(0x1a1a2e);

                    const aspect = container.clientWidth / container.clientHeight;
                    const frustumSize = 60;
                    this.camera = new THREE.OrthographicCamera(
                        frustumSize * aspect / -2,
                        frustumSize * aspect / 2,
                        frustumSize / 2,
                        frustumSize / -2,
                        0.1, 1000
                    );
                    this.camera.position.set(0, 12, 50);
                    this.camera.lookAt(0, 12, 0);

                    // æ¸…ç†æ—§çš„ renderer dom å…ƒç´ 
                    while (container.firstChild) {
                        container.removeChild(container.firstChild);
                    }

                    this.renderer = new THREE.WebGLRenderer({ antialias: true });
                    this.renderer.setSize(container.clientWidth, container.clientHeight);
                    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    container.appendChild(this.renderer.domElement);

                    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
                    this.scene.add(ambient);

                    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    dirLight.position.set(0, 40, 30);
                    this.scene.add(dirLight);

                    const gridHelper = new THREE.GridHelper(100, 10, 0x444444, 0x333333);
                    this.scene.add(gridHelper);

                    this.animate();
                },

                animate() {
                    if (!this.isOpen) return;
                    requestAnimationFrame(() => this.animate());
                    this.renderer.render(this.scene, this.camera);
                },

                // åŠ è½½å¹¶æ˜¾ç¤ºæ¨¡å‹
                async viewModel(packId, skinIndex) {
                    const pack = state.skinPacks.find(p => p.id === packId);
                    if (!pack) return;

                    try {
                        // è·å–çš®è‚¤ä¿¡æ¯
                        const skinsData = JSON.parse(pack.files['skins.json']._content);
                        const skin = skinsData.skins[skinIndex];
                        if (!skin) {
                            logger.add('âŒ æœªæ‰¾åˆ°çš®è‚¤æ•°æ®');
                            return;
                        }

                        const geometryName = skin.geometry;
                        const textureName = skin.texture.toLowerCase();

                        // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
                        if (!pack.files['geometry.json']) {
                            logger.add('âŒ ç¼ºå°‘ geometry.json');
                            return;
                        }

                        // è§£ægeometry
                        let geoContent = pack.files['geometry.json']._content;
                        // å§‹ç»ˆå°è¯•è‡ªåŠ¨ä¿®å¤ JSON æ ¼å¼
                        geoContent = this.fixJsonSyntax(utils.removeCommentsAndFixGeometry(geoContent));

                        let geoData;
                        try {
                            geoData = this.parseGeometry(JSON.parse(geoContent));
                        } catch (e) {
                            // å¦‚æœè¿˜æ˜¯å¤±è´¥ï¼Œå†å°è¯•æ›´æ¿€è¿›çš„ä¿®å¤
                            logger.add(`âš ï¸ ç¬¬ä¸€æ¬¡ä¿®å¤å¤±è´¥ï¼Œå°è¯•æ›´æ¿€è¿›çš„ä¿®å¤...`);
                            const moreFixed = utils.fixJsonSyntax(geoContent);
                            geoData = this.parseGeometry(JSON.parse(moreFixed));
                        }

                        if (!geoData[geometryName]) {
                            logger.add(`âŒ æœªæ‰¾åˆ°æ¨¡å‹: ${geometryName}`);
                            return;
                        }

                        // åŠ è½½è´´å›¾
                        this.currentTexture = null;
                        const textureFile = pack.files[textureName];
                        if (textureFile) {
                            const blob = textureFile.blob || new Blob([textureFile._content || '']);
                            const url = URL.createObjectURL(blob);
                            const loader = new THREE.TextureLoader();
                            this.currentTexture = await new Promise((resolve, reject) => {
                                loader.load(url, (tex) => {
                                    tex.magFilter = THREE.NearestFilter;
                                    tex.minFilter = THREE.NearestFilter;
                                    tex.flipY = false;
                                    URL.revokeObjectURL(url);
                                    resolve(tex);
                                }, undefined, reject);
                            });
                        }

                        // æ˜¾ç¤ºé¢„è§ˆåŒºåŸŸ
                        this.openViewer(packId, skinIndex, skin.localization_name || `skin_${skinIndex}`);

                        // æ„å»ºæ¨¡å‹
                        if (this.currentMesh) {
                            this.scene.remove(this.currentMesh);
                            this.currentMesh.geometry?.dispose();
                            this.currentMesh.material?.dispose();
                        }

                        const geometry = this.buildMesh(geoData, geometryName, this.currentTexture);
                        if (!geometry) {
                            logger.add('âŒ æ¨¡å‹æ„å»ºå¤±è´¥');
                            return;
                        }

                        const material = new THREE.MeshStandardMaterial({
                            color: 0xffffff,
                            map: this.currentTexture,
                            transparent: true,
                            alphaTest: 0.1,
                            side: THREE.DoubleSide,
                            roughness: 0.8,
                            metalness: 0.0
                        });

                        this.currentMesh = new THREE.Mesh(geometry, material);
                        this.currentMesh.rotation.set(0, 0, 0);
                        this.scene.add(this.currentMesh);

                        logger.add(`âœ… å·²åŠ è½½æ¨¡å‹: ${geometryName} + ${textureName}`);

                    } catch (err) {
                        logger.add(`âŒ é¢„è§ˆå¤±è´¥: ${err.message}`);
                        console.error(err);
                    }
                },

                openViewer(packId, skinIndex, skinName) {
                    const viewerId = `model-viewer-${packId}-${skinIndex}`;
                    const canvasId = `modelViewerCanvas-${packId}-${skinIndex}`;
                    const container = document.getElementById(canvasId);
                    const viewerContainer = document.getElementById(viewerId);

                    if (!container || !viewerContainer) return;

                    // å…³é—­å…¶ä»–æ‰“å¼€çš„é¢„è§ˆ
                    document.querySelectorAll('.model-viewer-inline.expanded').forEach(el => {
                        if (el.id !== viewerId) el.classList.remove('expanded');
                    });

                    viewerContainer.classList.add('expanded');
                    this.isOpen = true;
                    this.initScene(container);

                    // é‡ç½®ç›¸æœº
                    if (this.camera) {
                        this.camera.zoom = 1;
                        this.camera.updateProjectionMatrix();
                    }

                    // æ»šåŠ¨åˆ°é¢„è§ˆåŒºåŸŸ
                    viewerContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
                },

                closeViewer(packId, skinIndex) {
                    const viewerId = `model-viewer-${packId}-${skinIndex}`;
                    const viewerContainer = document.getElementById(viewerId);
                    if (viewerContainer) {
                        viewerContainer.classList.remove('expanded');
                    }
                    this.isOpen = false;
                    if (this.currentMesh) {
                        this.scene.remove(this.currentMesh);
                        this.currentMesh.geometry?.dispose();
                        this.currentMesh.material?.dispose();
                        this.currentMesh = null;
                    }
                }
            };

            // UI æ¸²æŸ“
            const renderer = {
                packsList() {
                    const { skinPacks } = state;
                    
                    if (skinPacks.length === 0) {
                        elements.packsListContainer.style.display = 'none';
                        elements.emptyState.style.display = 'block';
                        return;
                    }

                    elements.packsListContainer.style.display = 'block';
                    elements.emptyState.style.display = 'none';
                    elements.packCount.textContent = `${skinPacks.length} ä¸ª`;

                    elements.packsList.innerHTML = skinPacks.map((pack, index) => this.createPackItem(pack, index)).join('');
                    this.attachDragEvents();
                    this.attachExpandEvents();
                },

                createPackItem(pack, index) {
                    const isReady = pack.status === 'ready';
                    const isError = pack.status === 'error';
                    
                    // è§£æskinsæ•°æ®ç”¨äºæ˜¾ç¤º
                    let skins = [];
                    if (isReady && pack.files['skins.json']) {
                        try {
                            const data = JSON.parse(pack.files['skins.json']._content);
                            skins = data.skins || [];
                        } catch (e) {
                            console.error('Failed to parse skins for display:', e);
                        }
                    }

                    return `
                        <div class="pack-item ${isError ? 'error' : ''}" data-index="${index}" draggable="${!isError}" data-id="${pack.id}">
                            <div class="pack-header">
                                <div class="pack-handle" style="${isError ? 'opacity: 0.3; cursor: not-allowed;' : ''}">
                                    <i class="fas fa-grip-vertical"></i>
                                </div>
                                <div class="pack-number">${index + 1}</div>
                                <div class="pack-info">
                                    <div class="pack-name">${pack.fileName}</div>
                                    ${pack.rootPath ? `<div class="pack-path"><i class="fas fa-folder-open"></i> ${pack.rootPath}</div>` : ''}
                                    <div class="pack-meta">
                                        ${isReady
                                            ? `<span class="pack-status"><i class="fas fa-check-circle"></i> ${pack.skinCount} ä¸ªçš®è‚¤</span>`
                                            : isError
                                                ? `<span class="pack-status error"><i class="fas fa-exclamation-circle"></i> ${pack.errorMsg || 'åŠ è½½å¤±è´¥'}</span>`
                                                : `<span class="pack-status" style="background: rgba(59, 133, 38, 0.1); color: #3b8526;"><i class="fas fa-spinner fa-spin"></i> è¯»å–ä¸­...</span>`
                                        }
                                    </div>
                                </div>
                                <div class="pack-actions">
                                    ${isReady ? `
                                        <button class="pack-btn expand" onclick="window.togglePackExpand('${pack.id}')" title="å±•å¼€/æ”¶èµ·çš®è‚¤åˆ—è¡¨">
                                            <i class="fas fa-list"></i>
                                            <span>æŸ¥çœ‹</span>
                                        </button>
                                    ` : ''}
                                    <button class="pack-btn delete" onclick="window.removePack('${pack.id}')" title="åˆ é™¤æ•´ä¸ªçš®è‚¤åŒ…">
                                        <i class="fas fa-trash-alt"></i>
                                    </button>
                                </div>
                            </div>
                            ${isReady ? `
                                <div class="skins-expandable" id="skins-expand-${pack.id}">
                                    <div class="skins-list" id="skins-list-${pack.id}">
                                        <div class="skins-list-header" id="skins-list-header-${pack.id}">
                                            <div class="skins-list-header-left">
                                                <span style="font-size: 12px; color: var(--mc-text-muted);">å¤šé€‰çš®è‚¤</span>
                                            </div>
                                            <button class="btn-toggle-multi" id="btn-multi-delete-${pack.id}" onclick="window.deleteSelectedSkins('${pack.id}')" disabled>
                                                <i class="fas fa-trash-alt"></i>
                                                <span>åˆ é™¤é€‰ä¸­ (<span id="selected-count-${pack.id}">0</span>)</span>
                                            </button>
                                        </div>
                                        ${skins.map((skin, idx) => this.createSkinItem(pack.id, skin, idx, skins.length)).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                },

                createSkinItem(packId, skin, index, total) {
                    const animKeys = skin.animations ? Object.keys(skin.animations) : [];
                    const hasHideArmor = skin.hide_armor === true;
                    const canDelete = total > 1;

                    return `
                        <div class="skin-item" data-skin-index="${index}" id="skin-item-${packId}-${index}">
                            <div class="skin-checkbox-wrapper">
                                <input type="checkbox" class="skin-checkbox" data-pack-id="${packId}" data-skin-index="${index}" onchange="window.updateSelectedCount('${packId}')" title="é€‰æ‹©æ­¤çš®è‚¤">
                            </div>
                            <div class="skin-index">${index + 1}</div>
                            <div class="skin-details">
                                <div class="skin-name">
                                    <i class="fas fa-user-circle" style="color: var(--mc-green);"></i>
                                    ${skin.localization_name || `skin_${index}`}
                                </div>
                                <div class="skin-geometry">
                                    <i class="fas fa-cube" style="font-size: 10px;"></i> ${skin.geometry}
                                </div>
                                <div class="skin-texture">
                                    <i class="fas fa-image" style="font-size: 10px;"></i> ${skin.texture}
                                </div>
                                ${animKeys.length > 0 ? `
                                    <div class="skin-animations">
                                        ${animKeys.slice(0, 3).map(key => `
                                            <span class="anim-tag">${key}</span>
                                        `).join('')}
                                        ${animKeys.length > 3 ? `<span class="anim-tag">+${animKeys.length - 3}</span>` : ''}
                                    </div>
                                ` : ''}
                                <div class="skin-flags">
                                    <span class="flag-tag ${hasHideArmor ? 'active' : ''}">
                                        <i class="fas fa-tshirt"></i> ${hasHideArmor ? 'éšè—ç›”ç”²' : 'æ˜¾ç¤ºç›”ç”²'}
                                    </span>
                                    <span class="flag-tag">
                                        <i class="fas fa-tag"></i> ${skin.type || 'free'}
                                    </span>
                                </div>
                            </div>
                            <button class="skin-view-btn" onclick="window.viewSkinModel('${packId}', ${index})" title="æŸ¥çœ‹3Dæ¨¡å‹">
                                <i class="fas fa-eye"></i>
                            </button>
                            <button class="skin-delete-btn" onclick="window.deleteSkin('${packId}', ${index})"
                                    title="${canDelete ? 'åˆ é™¤æ­¤çš®è‚¤' : 'è‡³å°‘éœ€è¦ä¿ç•™1ä¸ªçš®è‚¤'}" ${!canDelete ? 'disabled' : ''}>
                                <i class="fas fa-trash-alt"></i>
                            </button>
                        </div>
                        <div class="model-viewer-inline" id="model-viewer-${packId}-${index}">
                            <div class="model-viewer-inline-content">
                                <div class="model-viewer-header">
                                    <span><i class="fas fa-cube"></i> 3D é¢„è§ˆ</span>
                                    <button class="pack-btn delete" onclick="window.closeModelViewer('${packId}', ${index})" title="å…³é—­">
                                        <i class="fas fa-times"></i>
                                    </button>
                                </div>
                                <div class="model-viewer-canvas" id="modelViewerCanvas-${packId}-${index}"></div>
                            </div>
                        </div>
                    `;
                },

                attachDragEvents() {
                    const items = elements.packsList.querySelectorAll('.pack-item:not(.error)');
                    items.forEach(item => {
                        item.addEventListener('dragstart', e => {
                            state.dragStartIndex = +item.dataset.index;
                            item.classList.add('dragging');
                            e.dataTransfer.effectAllowed = 'move';
                        });
                        item.addEventListener('dragend', () => item.classList.remove('dragging'));
                        item.addEventListener('dragover', e => e.preventDefault());
                        item.addEventListener('dragenter', () => item.classList.add('drag-over'));
                        item.addEventListener('dragleave', () => item.classList.remove('drag-over'));
                        item.addEventListener('drop', e => {
                            e.stopPropagation();
                            const endIndex = +item.dataset.index;
                            if (state.dragStartIndex !== endIndex) {
                                const [moved] = state.skinPacks.splice(state.dragStartIndex, 1);
                                state.skinPacks.splice(endIndex, 0, moved);
                                logger.add(`ğŸ”„ å·²è°ƒæ•´é¡ºåº: å°†ç¬¬ ${state.dragStartIndex + 1} ä½ç§»è‡³ç¬¬ ${endIndex + 1} ä½`);
                                this.packsList();
                            }
                        });
                    });
                },

                attachExpandEvents() {
                    // ç‚¹å‡»å±•å¼€æŒ‰é’®çš„äº‹ä»¶é€šè¿‡onclickå†…è”å¤„ç†
                },

                updateUI() {
                    const readyPacks = state.skinPacks.filter(p => p.status === 'ready');
                    const allReady = readyPacks.length === state.skinPacks.length && state.skinPacks.length >= 2;
                    
                    elements.mergeBtn.disabled = !allReady || state.mergeInProgress;
                    elements.mergeBtnText.textContent = state.skinPacks.length < 2 
                        ? `è¯·è‡³å°‘ä¸Šä¼  2 ä¸ªçš®è‚¤åŒ… (${state.skinPacks.length}/2)` 
                        : `å¼€å§‹åˆå¹¶ ${state.skinPacks.length} ä¸ªçš®è‚¤åŒ…`;
                },

                refreshPackSkins(packId) {
                    // åªåˆ·æ–°æŒ‡å®špackçš„çš®è‚¤åˆ—è¡¨éƒ¨åˆ†
                    const pack = state.skinPacks.find(p => p.id === packId);
                    if (!pack || !pack.files['skins.json']) return;

                    const skinsListEl = document.getElementById(`skins-list-${packId}`);
                    if (!skinsListEl) return;

                    try {
                        const data = JSON.parse(pack.files['skins.json']._content);
                        const skins = data.skins || [];
                        pack.skinCount = skins.length;
                        
                        // æ›´æ–°å¤´éƒ¨è®¡æ•°
                        const packItem = document.querySelector(`[data-id="${packId}"]`);
                        if (packItem) {
                            const statusEl = packItem.querySelector('.pack-status');
                            if (statusEl) {
                                statusEl.innerHTML = `<i class="fas fa-check-circle"></i> ${pack.skinCount} ä¸ªçš®è‚¤`;
                            }
                        }

                        // ä¿ç•™å¤´éƒ¨æ ï¼ˆå¤šé€‰åˆ é™¤å·¥å…·æ ï¼‰ï¼Œåªåˆ·æ–°çš®è‚¤åˆ—è¡¨
                        const headerEl = document.getElementById(`skins-list-header-${packId}`);
                        const headerHTML = headerEl ? headerEl.outerHTML : '';

                        skinsListEl.innerHTML = headerHTML + skins.map((skin, idx) => this.createSkinItem(packId, skin, idx, skins.length)).join('');

                        // é‡æ–°ç»‘å®š checkbox äº‹ä»¶å’Œæ›´æ–°è®¡æ•°
                        window.updateSelectedCount(packId);
                    } catch (e) {
                        console.error('Failed to refresh skins:', e);
                    }
                }
            };

            // äº‹ä»¶å¤„ç†
            const events = {
                init() {
                    // ä¸Šä¼ äº‹ä»¶
                    elements.uploadZone.addEventListener('click', () => elements.fileInput.click());
                    elements.uploadZone.addEventListener('dragover', e => {
                        e.preventDefault();
                        elements.uploadZone.classList.add('dragover');
                    });
                    elements.uploadZone.addEventListener('dragleave', () => elements.uploadZone.classList.remove('dragover'));
                    elements.uploadZone.addEventListener('drop', e => {
                        e.preventDefault();
                        elements.uploadZone.classList.remove('dragover');
                        this.handleFiles(Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.zip')));
                    });
                    elements.fileInput.addEventListener('change', e => {
                        this.handleFiles(Array.from(e.target.files));
                        elements.fileInput.value = '';
                    });

                    // é¢„è®¾æŒ‰é’®
                    document.querySelectorAll('.preset-pill').forEach(btn => {
                        btn.addEventListener('click', () => {
                            btn.classList.toggle('active');
                            const presetId = btn.dataset.preset;
                            const isActive = btn.classList.contains('active');
                            logger.add(`${isActive ? 'âœ…' : 'âŒ'} ${isActive ? 'å·²å¯ç”¨' : 'å·²å…³é—­'}é¢„è®¾${presetId}ï¼š${PRESET_CONFIGS[presetId].name}`);
                            this.applyPresets();
                        });
                    });

                    // åˆå¹¶æŒ‰é’®
                    elements.mergeBtn.addEventListener('click', () => this.startMerge());

                    // å…¨å±€å‡½æ•°
                    window.removePack = id => {
                        const idx = state.skinPacks.findIndex(p => p.id === id);
                        if (idx !== -1) {
                            const pack = state.skinPacks[idx];
                            state.skinPacks.splice(idx, 1);
                            state.modelTextureRelations.delete(pack.id);
                            logger.add(`ğŸ—‘ï¸ å·²ç§»é™¤ ${pack.fileName}`);
                            renderer.packsList();
                            renderer.updateUI();
                        }
                    };

                    window.togglePackExpand = packId => {
                        const expandEl = document.getElementById(`skins-expand-${packId}`);
                        if (expandEl) {
                            expandEl.classList.toggle('expanded');
                            const btn = document.querySelector(`[data-id="${packId}"] .pack-btn.expand`);
                            if (btn) {
                                const isExpanded = expandEl.classList.contains('expanded');
                                btn.innerHTML = isExpanded ? 
                                    '<i class="fas fa-chevron-up"></i><span>æ”¶èµ·</span>' : 
                                    '<i class="fas fa-list"></i><span>æŸ¥çœ‹</span>';
                            }
                        }
                    };

                    window.deleteSkin = (packId, skinIndex) => {
                        if (skinDeleter.deleteSkin(packId, skinIndex)) {
                            renderer.refreshPackSkins(packId);
                        }
                    };

                    // å¤šé€‰åˆ é™¤ç›¸å…³å‡½æ•°
                    window.updateSelectedCount = (packId) => {
                        const checkboxes = document.querySelectorAll(`.skin-checkbox[data-pack-id="${packId}"]`);
                        const selectedCount = Array.from(checkboxes).filter(cb => cb.checked).length;
                        const countDisplay = document.getElementById(`selected-count-${packId}`);
                        const deleteBtn = document.getElementById(`btn-multi-delete-${packId}`);

                        if (countDisplay) {
                            countDisplay.textContent = selectedCount;
                        }
                        if (deleteBtn) {
                            deleteBtn.disabled = selectedCount === 0;
                        }

                        // æ›´æ–°é€‰ä¸­é¡¹çš„é«˜äº®çŠ¶æ€
                        checkboxes.forEach(cb => {
                            const skinIndex = cb.dataset.skinIndex;
                            const skinItem = document.getElementById(`skin-item-${packId}-${skinIndex}`);
                            if (skinItem) {
                                skinItem.classList.toggle('multi-selected', cb.checked);
                            }
                        });
                    };

                    window.deleteSelectedSkins = (packId) => {
                        const checkboxes = document.querySelectorAll(`.skin-checkbox[data-pack-id="${packId}"]`);
                        const selectedIndices = Array.from(checkboxes)
                            .filter(cb => cb.checked)
                            .map(cb => parseInt(cb.dataset.skinIndex))
                            .sort((a, b) => b - a); // ä»å¤§åˆ°å°åˆ é™¤ï¼Œé¿å…ç´¢å¼•åç§»

                        if (selectedIndices.length === 0) return;

                        const pack = state.skinPacks.find(p => p.id === packId);
                        if (!pack || !pack.files['skins.json']) return;

                        const skinsData = JSON.parse(pack.files['skins.json']._content);
                        const remainingSkins = skinsData.skins.length - selectedIndices.length;

                        if (remainingSkins < 1) {
                            logger.add(`âš ï¸ æ— æ³•åˆ é™¤ï¼š${pack.fileName} è‡³å°‘éœ€è¦ä¿ç•™ 1 ä¸ªçš®è‚¤`);
                            return;
                        }

                        // æ‰¹é‡åˆ é™¤çš®è‚¤
                        let deletedCount = 0;
                        for (const skinIndex of selectedIndices) {
                            const deletedSkin = skinsData.skins[skinIndex];
                            if (deletedSkin) {
                                skinDeleter.cleanupUnusedTexture(pack, deletedSkin.texture, 
                                    skinsData.skins.filter((_, idx) => !selectedIndices.includes(idx)));
                                deletedCount++;
                            }
                        }

                        // è¿‡æ»¤æ‰é€‰ä¸­çš„çš®è‚¤
                        skinsData.skins = skinsData.skins.filter((_, idx) => !selectedIndices.includes(idx));
                        
                        // æ›´æ–°æ–‡ä»¶å†…å®¹
                        pack.files['skins.json']._content = JSON.stringify(skinsData, null, 2);
                        pack.skinCount = skinsData.skins.length;

                        logger.add(`ğŸ—‘ï¸ å·²æ‰¹é‡åˆ é™¤ ${deletedCount} ä¸ªçš®è‚¤ (${pack.fileName})`);
                        renderer.refreshPackSkins(packId);
                    };

                    // æ¨¡å‹é¢„è§ˆå…¨å±€å‡½æ•°
                    window.viewSkinModel = (packId, skinIndex) => {
                        window.ModelViewer.viewModel(packId, skinIndex);
                    };

                    window.closeModelViewer = (packId, skinIndex) => {
                        window.ModelViewer.closeViewer(packId, skinIndex);
                    };
                },

                async handleFiles(files) {
                    const newPacks = [];
                    
                    for (const file of files) {
                        if (!file.name.endsWith('.zip')) continue;
                        
                        const existingIdx = state.skinPacks.findIndex(p => p.fileName === file.name);
                        if (existingIdx !== -1) {
                            logger.add(`âš ï¸ ${file.name} å·²å­˜åœ¨ï¼Œå°†æ›¿æ¢æ—§ç‰ˆæœ¬`);
                            state.skinPacks.splice(existingIdx, 1);
                        }

                        newPacks.push({
                            id: `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                            fileName: file.name,
                            name: utils.getSafeFileName(file.name.replace('.zip', '')),
                            files: {},
                            status: 'loading',
                            rootPath: ''
                        });
                    }

                    state.skinPacks.push(...newPacks);
                    renderer.packsList();

                    await Promise.all(newPacks.map(async pack => {
                        const file = files.find(f => f.name === pack.fileName);
                        if (!file) return;

                        try {
                            logger.add(`æ­£åœ¨è¯»å– ${pack.fileName}...`);
                            await fileHandler.extractZip(file, pack);
                            
                            const missing = CORE_FILES.filter(f => !pack.files[f]);
                            if (missing.length) throw new Error(`ç¼ºå°‘æ ¸å¿ƒæ–‡ä»¶: ${missing.join(' ')}`);
                            
                            pack.skinCount = utils.countSkins(await pack.files['skins.json'].content);
                            pack.status = 'ready';
                            logger.add(`âœ… ${pack.fileName} å·²åŠ è½½ (${pack.skinCount} ä¸ªçš®è‚¤)`);
                            if (pack.rootPath) logger.add(`   ğŸ“ æ£€æµ‹åˆ°å­æ–‡ä»¶å¤¹ç»“æ„: ${pack.rootPath}`);
                        } catch (err) {
                            pack.status = 'error';
                            pack.errorMsg = err.message;
                            logger.add(`âŒ ${pack.fileName} è¯»å–å¤±è´¥: ${err.message}`);
                        }
                        renderer.packsList();
                    }));

                    renderer.updateUI();
                },

                applyPresets() {
                    const activePresets = document.querySelectorAll('.preset-pill.active');
                    const settings = { compatibleRenameModel: false, simplifyNaming: false, replaceUuid: false, addHideArmor: false, fixComments: false, outputMcpack: false };
                    
                    activePresets.forEach(btn => {
                        Object.assign(settings, PRESET_CONFIGS[btn.dataset.preset].settings);
                    });

                    Object.entries(settings).forEach(([key, val]) => {
                        const el = document.getElementById(key);
                        if (el) el.checked = val;
                    });
                },

                async startMerge() {
                    if (state.mergeInProgress) return;
                    state.mergeInProgress = true;
                    renderer.updateUI();
                    
                    elements.progressContainer.style.display = 'block';
                    elements.resultContainer.style.display = 'none';
                    logger.add('=== å¼€å§‹åˆå¹¶çš®è‚¤åŒ… ===');
                    logger.add(`ğŸ“¦ å…±åˆå¹¶ ${state.skinPacks.length} ä¸ªçš®è‚¤åŒ…`);

                    try {
                        utils.updateProgress(10, 'è¯»å–æ ¸å¿ƒæ–‡ä»¶...');
                        const packsData = await Promise.all(state.skinPacks.map(async (pack, i) => ({
                            pack,
                            core: await fileHandler.loadCore(pack.files, `åŒ…${i + 1}(${pack.name})`)
                        })));

                        utils.updateProgress(25, 'æ‰«ææ¨¡å‹-è´´å›¾å…³è”å…³ç³»...');
                        packsData.forEach(({ pack, core }) => relationScanner.scan(core, pack.id));

                        utils.updateProgress(40, elements.compatibleRenameModel.checked ? 'æ‰§è¡Œé‡åæ¨¡å‹å…¼å®¹å‘½å...' : 
                            (elements.simplifyNaming.checked ? 'æ‰§è¡Œå‘½åç®€åŒ–...' : 'å¤„ç†é‡å¤å­—æ®µ...'));

                        const result = await this.processPacks(packsData);
                        
                        if (elements.addHideArmor.checked) {
                            utils.updateProgress(60, 'å¤„ç†éšè—ç›”ç”²...');
                            result.skins = result.skins.map(s => s.type === 'free' && !s.hide_armor ? { ...s, hide_armor: true } : s);
                            const count = result.skins.filter(s => s.hide_armor).length;
                            if (count) logger.add(`ğŸ›¡ï¸ å·²ä¸º ${count} ä¸ªçš®è‚¤å¯ç”¨éšè—ç›”ç”²`);
                        }

                        utils.updateProgress(70, 'åˆå¹¶æ–‡ä»¶...');
                        const outputFiles = this.buildOutputFiles(result, packsData[0].core['manifest.json']);

                        utils.updateProgress(80, 'æ”¶é›†è´´å›¾æ–‡ä»¶...');
                        this.collectTextures(outputFiles, state.skinPacks);

                        utils.updateProgress(90, 'ç”Ÿæˆå‹ç¼©åŒ…...');
                        const zipBlob = await this.generateZip(outputFiles);
                        const suffix = elements.outputMcpack.checked ? '.mcpack' : '.zip';
                        const fileName = `merged_${state.skinPacks.length}packs_${Date.now()}${suffix}`;

                        utils.updateProgress(100, 'å®Œæˆï¼');
                        elements.resultContainer.style.display = 'block';
                        elements.downloadBtn.onclick = () => saveAs(zipBlob, fileName);
                        logger.add(`âœ… åˆå¹¶æˆåŠŸï¼å…± ${result.skins.length} ä¸ªçš®è‚¤`);

                    } catch (err) {
                        logger.add(`âŒ é”™è¯¯: ${err.message}`);
                        console.error(err);
                    } finally {
                        state.mergeInProgress = false;
                        renderer.updateUI();
                    }
                },

                async processPacks(packsData) {
                    const allSkins = [];
                    const mergedGeo = {};
                    
                    for (let i = 0; i < packsData.length; i++) {
                        const { pack, core } = packsData[i];
                        const startIdx = allSkins.length;
                        let result;

                        if (elements.compatibleRenameModel.checked) {
                            result = namingHandler.compatibleSimplify(core, pack.id, startIdx);
                        } else if (elements.simplifyNaming.checked) {
                            result = namingHandler.simplifySingle(core, pack.id, startIdx);
                        } else {
                            const prefix = utils.getSafeFileName(pack.name).substring(0, 8) || `pack${i+1}`;
                            result = namingHandler.modifyDuplicate(core, allSkins, prefix);
                        }

                        allSkins.push(...result.modifiedSkins);
                        
                        Object.entries(core['geometry.json']).forEach(([key, val]) => {
                            mergedGeo[result.geoRenameMap.get(key) || key] = val;
                        });

                        pack.geoRenameMap = result.geoRenameMap;
                        pack.textureMap = result.textureMap;
                    }

                    return { skins: allSkins, geometry: mergedGeo };
                },

                buildOutputFiles(result, manifest) {
                    if (elements.replaceUuid.checked && manifest) {
                        manifest.header.uuid = utils.generateUUID();
                        if (manifest.modules) manifest.modules[0].uuid = utils.generateUUID();
                    }

                    // è‡ªå®šä¹‰æ ¼å¼åŒ– geometry.jsonï¼Œåœ¨æœ€åä¸€ä¸ª geometry å¯¹è±¡çš„å¤§æ‹¬å·åä¹Ÿæ·»åŠ é€—å·
                    const geometryKeys = Object.keys(result.geometry);
                    let geometryJsonStr = '';
                    
                    geometryKeys.forEach((key) => {
                        const val = result.geometry[key];
                        const geoStr = `    "${key}": ${JSON.stringify(val, null, 4).replace(/^/gm, '    ')}`;
                        geometryJsonStr += geoStr + ',\n';
                    });

                    const finalGeometryJson = `{\n${geometryJsonStr}}`;

                    return {
                        'manifest.json': JSON.stringify(manifest),
                        'skins.json': JSON.stringify({ skins: result.skins }),
                        'geometry.json': finalGeometryJson
                    };
                },

                collectTextures(outputFiles, packs) {
                    packs.forEach(pack => {
                        Object.entries(pack.files).forEach(([name, file]) => {
                            if (name.endsWith('.png') || name.endsWith('.jpg')) {
                                const newName = pack.textureMap.get(name) || name;
                                outputFiles[newName] = file.blob || file;
                            }
                        });
                    });
                },

                async generateZip(files) {
                    const zip = new JSZip();
                    Object.entries(files).forEach(([name, content]) => {
                        zip.file(name, typeof content === 'string' ? content : content);
                    });
                    return await zip.generateAsync({ type: 'blob', compression: 'DEFLATE' });
                }
            };

            // åˆå§‹åŒ–
            events.init();
        })();
    </script>
</body>
</html>
